================================================================================================================================================

1. Two Sum

public class Solution {
    public int[] twoSum(int[] nums, int target) {
 

    int i,j;
 
    int r[]=new int[2];
    
    for (i=0;i<nums.length-1;i++)
    {
        for (j=i+1;j<nums.length;j++)
        {
         if (nums[i]+nums[j]==target)
         {
          r[0]=i;
          r[1]=j;
          return(r);
         }
       }
    }

   return (null); 
}
}


================================================================================================================================================

2. Add Two Numbers

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        
        ListNode r= new ListNode(0);
        ListNode rf = r;
        ListNode pr = r;
        int togo=0;
        int vl1=-1;
        int vl2=-1;
        
        while (vl1+vl2-togo<0)
         {
          int x=togo;
          if (vl1<0) x=x+l1.val;
          if (vl2<0) x=x+l2.val;  
          togo=x/10;  
          r.val=x%10;
          ListNode temp=new ListNode(0);
          r.next=temp;
          pr=r;  
          r=r.next;
          if (l1.next!=null) 
           l1=l1.next;
          else
           vl1=0;   
          if (l2.next!=null) 
           l2=l2.next;
          else
           vl2=0;  
         }  
     pr.next=null; 
     return(rf);   
    }
}

================================================================================================================================================

3. Longest Substring Without Repeating Characters

C

bool repete(char * s, char c,int inicio,int final)
{
 int i=inicio;
    
 while (i<final)
  {  
   if (s[i]==c) return(true);
   i++;
  }  
 return(false);   
}  
    

int lengthOfLongestSubstring(char * s){
    
    int lng = 0;
    int i,j=0,sz=strlen(s);

    while (j+lng<sz)
     {   
      i=j;
      while ((i<sz) & !(repete(s,s[i],j,i))) i++;
      if (i-j>lng)
         lng = i-j; 
      j++;
     }   
    return(lng);

}



C++

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        
    int lng = 0;
    int i,j=0,sz=s.size();

    while (j+lng<sz)
     {   
      i=j;
      while (i<sz & (s.substr(j,i-j).find(s[i])==string::npos)) i++;  
      if (i-j>lng)
         lng = i-j; 
      j++;
     }   
    return(lng);
        
    }
};


================================================================================================================================================

4. Median of Two Sorted Arrays

class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
      
    int pos,i=0,j=0,extra=0;
        
    double med; 
        
    int size1,size2;    
    
    size1=nums1.size();
    size2=nums2.size(); 
        
    if ((size1==0) & (size2==0)) return (NULL);
    
    if (size1==0)    
     {
      if ((size2-1)%2==0)
       return(nums2[(size2-1)/2]);
      else
       { 
        med=(double)((nums2[(size2-1)/2])+(nums2[(size2-1)/2+1]))/2;  
        return(med);
       }  
     }

    if (size2==0)    
     {
      if ((size1-1)%2==0)
       return(nums1[(size1-1)/2]);
      else
       { 
        med=(double)((nums1[(size1-1)/2])+(nums1[(size1-1)/2+1]))/2;  
        return(med);
       }  
     }
        
        
    pos = size1+size2-1;
    if (pos%2!=0) extra=1;
    pos = pos/2;    
    
    while (pos>0)
     {
      if ((i<size1) & (j<size2))
       {   
        if (nums1[i]<nums2[j])
          i++;
        else
          j++; 
       }
      else
       {
        if (i<size1) 
         i++;
        else
         j++;   
       } 
      pos--;
     }  
    if ((i<size1) & (j<size2))
     {   
      if (nums1[i]<nums2[j])
        {
         med=nums1[i];
         i++;  
        }
       else
        {
         med=nums2[j];
         j++;  
        }
     }
    else
     {
      if (i<size1)
       {
        med=nums1[i];
        i++;  
       }
      else
       {
        med=nums2[j];
        j++;   
       }   
     }   
    if (extra!=0)
     {
      if ((i<size1) & (j<size2))
       {   
        if (nums1[i]<nums2[j])
          med=(med+(double)nums1[i])/2;
        else
          med=(med+(double)nums2[j])/2;
       } 
      else
       {
        if (i<size1)
          med=(med+(double)nums1[i])/2; 
        else
          med=(med+(double)nums2[j])/2;
       }   
     }  
    return(med);    
    }
};


================================================================================================================================================

5. Longest Palindromic Substring

public class Solution {
    public String longestPalindrome(String s) {

 
   int i,j,k,kk,jj,v;
   int imax=0;
   int jmax=1;
   
   if (s.length()==0) return(s);
   
 
  
   for (i=0;i<s.length();i++) /* Looking each char in the string */
    {
     k=i;
     j=jmax;
     for (v=0;v<=1;v++) /* Twice, for even and odd size palindromes*/
      {
       j++;
       if ((k-j/2+j<=s.length()) && (k-j/2>=0)) /* Checking if verification is not outside of the string */
        {
         if (ispal (s.substring(k-j/2,k-j/2+j)))  /* If is palindrome ... */
          { 
           kk=k-j/2;
           jj=j;
           while (s.charAt(kk)==s.charAt(kk+jj-1)) /* Try to see if adding one more char on each side is still palindrome */
            {
             kk--;
             jj++;
             jj++;
             if ((kk<0) || (kk+jj>s.length())) break; /* If not inside string, stop */
            }
           kk++;  /* Discard last two chars that did not work */
           jj--;
           jj--;
           imax=kk;  /* New max values */
           jmax=jj;
           j=jmax;
          }
        }
      } 
    }
   return (s.substring(imax,imax+jmax)); /* Return the longest string */
}
        


  boolean ispal (String s)  /* Check if string is palindrome */
    {
     int i;    
     for (i=0;i<s.length()-i-1;i++)
      {
       if (s.charAt(i)!=s.charAt(s.length()-i-1)) return (false);      
      }
     return (true); 
    }  
    

    
}

================================================================================================================================================

6. Zigzag Conversion

Solution 1.

#include <cctype>

class Solution {
public:
    string convert(string s, int numRows) {
        
    if (numRows==1) return(s);    
        
    int jump=2*numRows-2;
    int round=numRows-1;
    int loop=1+s.size()/(2*(numRows-1));    
    int i,r;
    string result="";
           
    
    r=0;
  
    while (r<=round)
     {   
      for (i=0;i<=jump*loop;i=i+jump)
       {
        if ((r>0 & r<round))
          {
           result=result+getstrpos(s,i-r);
           result=result+getstrpos(s,i+r); 
          }
        else
          result=result+getstrpos(s,i+r);  
       } 
      r++;  
     }
    return(removespaces(result));    
                      
}
    
 
 string removespaces(string s)
    {
     int pos;   
     while ((pos=s.find(" "))!=string::npos)
       s=s.substr(0,pos)+s.substr(pos+1,s.size()-pos-1);
     return(s);   
    }
    
    
    char getstrpos(string s, int pos)
    {
     if ((pos>=0) & (pos<s.size()))
      return(s[pos]);
     else
      return(' ');   
    }    
        
};

Solution 2.

#include <cctype>

class Solution {
public:
    string convert(string s, int numRows) {
        
    if (numRows==1) return(s);    
        
    int jump=2*numRows-2;
    int round=numRows-1;
    int loop=1+s.size()/(2*(numRows-1));    
    int i,r;
    string result="";
        
    
    r=0;
  
    while (r<=round)
     {   
      for (i=0;i<=jump*loop;i=i+jump)
       {
        if ((r>0 & r<round))
          {
           result=getstrpos(result,s,i-r);
           result=getstrpos(result,s,i+r); 
          }
        else
          result=getstrpos(result,s,i+r);  
       } 
      r++;  
     }
    return(result);    
                      
}
                      
    string getstrpos(string r, string s, int pos)
    {
     if ((pos>=0) & (pos<s.size()))
      return(r+s[pos]);
     else
      return(r);   
    }    
        
};

Solution using matrix:

class Solution {
public:
    string convert(string s, int numRows) {
    
    char x[numRows][s.size()];
        
    int i,j,k;
        
    bool zig=true;    
        
    string res="";   
        
    if (numRows==1) return(s);    
        
    for (i=0;i<numRows;i++)
     for (j=0;j<s.size();j++)
      x[i][j]=' ';
        
    i=0;
    j=0;
    k=0;    
        
    while (k<s.size())   
     {
      //cout <<i;
      //cout <<j; 
      if (zig)
       {
        x[i][j]=s[k];
        k++;
        i++;
        if (i==numRows)
         {
          i--;
          i--;  
          j++;
          zig=false;  
         }  
       }
      else
       {
        x[i][j]=s[k];
        k++;
        i--;
        j++;
        if (i<0)
         {
          i++;
          i++;  
          j--;
          zig=true;
         }  
       }   
     }   

        
    for (i=0;i<numRows;i++)
     for (j=0;j<s.size();j++) 
      if (x[i][j]!=' ')
        res=res+x[i][j];   
    return(res);    
    }    
        
};


And in C (faster)

char result[1000];

char getstrpos(char * s, int pos)
    {
     
     if ((pos>=0) & (pos<strlen(s)))
      {
       return(s[pos]);
      }  
     else
      return('$');   
    }    

char * convert(char * s, int numRows){
        
    if (numRows==1) return(s);
    
    int jump=2*numRows-2;
    int round=numRows-1;
    int loop=1+(strlen(s)/(2*(numRows-1)));    
    int i,r,rpos;
  
    
    r=0;
    
    rpos=0;
  
    while (r<=round)
     {   
       
      for (i=0;i<=jump*loop;i=i+jump)
       {
        if ((r>0) & (r<round))
          {
           result[rpos]=getstrpos(s,i-r);
           rpos++; 
           if (result[rpos-1]=='$') rpos--; 
           result[rpos]=getstrpos(s,i+r);
           rpos++;
           if (result[rpos-1]=='$') rpos--; 
          }
        else
         {  
          result[rpos]=getstrpos(s,i+r);
          rpos++;
          if (result[rpos-1]=='$') rpos--;  
         }   
       }
      r++;  
     }
    result[rpos]=0;
    return(result);    
}
    
 

================================================================================================================================================

7. Reverse Integer 

public class Solution {
    public int reverse(int x) {
        
 
    int r[] = new int[1000];
    int i,j;
    int neg=0;
    
    if (x<0) 
     {
         neg=1;
         x=-x;
     }
    j=0;
    while (x!=0)
    {
        r[j]=x%10;
        x=x/10;
        j++;
    }
    for (i=0;i<j;i++)
    {
        if (x*10/10!=x) return (0);     
        x=x*10+r[i];
    }
    if (neg==1) 
      return(-x);
    else
      return (x);
  }
}

================================================================================================================================================

8. String to Integer (atoi)  

int myAtoi(char* str) {
    
    int i,st=0;
    int value=0;

    int signal=1;
    i=st;
    while (str[i]==' ')
     {
         i++;
     }   
    st=i;
    if (str[st]=='-')
     {
         signal=-signal;
         st++;
     }
    else if (str[st]=='+')
     {
         st++;
     }

    for (i=st;i<strlen(str);i++)
    {
     if ((str[i]>='0') && (str[i]<='9'))
      {
       if (value*10/10!=value)
        {
           if (signal>0) return (0x7FFFFFFF);
           if (signal<0) return (0x80000000);
        }
       value=value*10-'0'+str[i];
   /*    printf(" %d\n",value);  */
       if (value < 0) 
        {
            if (signal>0) return (0x7FFFFFFF);
            if (signal<0) return (0x80000000);
        }
      }
     else
      break;
    }
    return(signal*value);
}


================================================================================================================================================

9. Palindrome Number

class Solution {
public:
    bool isPalindrome(int x) {
        
        int i = 1;
        int z = x;
        while (z>=10) 
           {  
            i++;
            z=z/10;
           }   
        return(isPal(x,i));      
    }
    
    
    bool isPal(int x, int size) {
        
        int z;
        
        if (x<0) return (false);
        if ((x<10) & (size==1))
           return (true);
        
        if ((x<100) & (size==2)) 
         {
          if (x/10 == x%10) return (true);   
         }   
        else
         {
          z = x/(pow(10,size-1));
          if (x%10 == z)
            return(isPal(x/10-z*(pow(10,size-2)),size-2)); 
         }   
        return(false);
    }    
 
    
    
};

================================================================================================================================================

12. Integer to Roman

public class Solution {
    public String intToRoman(int num) {
        
        String[][] rs = {{"","I","II","III","IV","V","VI","VII","VIII","IX"},
                         {"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"},
                         {"","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"},
                         {"","M","MM","MMM"}};
        String r="";
        int i=0;
        while (num>0)
         {
          r=rs[i][num%10]+r;
          num=num/10;
          i++;  
         }   
        return(r);
    } 
}

-------------------------------------------------

// Processing string just once (Faster)

public class Solution {
    public String intToRoman(int num) {
        
        String[][] rs = {{"","I","II","III","IV","V","VI","VII","VIII","IX"},
                         {"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"},
                         {"","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"},
                         {"","M","MM","MMM"}};
        int[] r={0,0,0,0};
        int i=0;
        while (num>0)
         {
          r[i]=num%10;
          num=num/10;
          i++;  
         }   
        return(rs[3][r[3]]+rs[2][r[2]]+rs[1][r[1]]+rs[0][r[0]]);
    } 
}

================================================================================================================================================

13. Roman to Integer

class Solution {
public:
    int romanToInt(string s) {
        
    
    #include <map>

   std::map<string, int> roman = {
    { "C", 100 },
    { "CC", 200 },
    { "CCC", 300 },
    { "CD", 400 },
    { "D", 500 },
    { "DC", 600 },
    { "DCC", 700 },
    { "DCCC", 800 },
    { "CM", 900 },
    { "M", 1000 },
    { "X", 10 },
    { "XX", 20 },
    { "XXX", 30 },
    { "XL", 40 },
    { "L", 50 },
    { "LX", 60 },
    { "LXX", 70 },
    { "LXXX", 80 },
    { "XC", 90 },
    { "I", 1},
    { "II", 2},
    { "III", 3},
    { "IV", 4},
    { "V", 5},
    { "VI", 6},
    { "VII", 7},
    { "VIII", 8},
    { "IX", 9}
   };     
        
   int r = 0;    
   int size = 4;
   int index = 0;
   string stemp;  
        
        
   while (size>0)
    {   
     if (index+size>s.size()) size = s.size()-index;
     
     if (size > 0)
        { 
         stemp = s.substr(index,size);
         if (roman.find(stemp)!=roman.end())
          {  
            r = r + roman.at(stemp);
            index = index + size;
            size = 4; 
          }     
         else
          {
           size = size - 1;
          }   
       }
    }
   return(r);     
  }
};



/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

================================================================================================================================================

19. Remove Nth Node From End of List

// First solution 

struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    

   struct ListNode* list1[50];  
        
   struct ListNode* addr = head;
   
   int i=0;     
   while (addr!=NULL) 
     {
      list1[i] = addr;
      i++; 
      addr = addr->next; 
     } 
    
    if (i>n)
     { 
      addr = list1[i-n-1];  
      if (n!=1)
         addr->next = list1[i-n+1];
      else
         addr->next = NULL;
     } 
    else
     {
      head = head->next;
     }   
    return(head);         
   
};    

// Second solution better. Enable for n greater than 30

#include <deque>
using namespace std;

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if (!head || !n)
        {
            return head;
        }



        struct ListNode* items[n+1];
        struct ListNode* toReturn = head;
        int count = 0;
        for (struct ListNode* currentItem = head; currentItem; currentItem = currentItem->next)
        {
            items[count%(n+1)]=currentItem;
            count++;
        }
       
        // In case we must remove the first item.
        if (count == n)
        {
            toReturn = head->next;
            delete head;
        }
        else 
        {
            items[count%(n+1)]->next = n == 1 ? nullptr : items[(count+2)%(n+1)];
        }

        return toReturn;
    }
};

================================================================================================================================================


20. Valid Parentheses 

public class Solution {
    public boolean isValid(String s) {
        
    String parse="";
    
    String open="[{(";
    String close="]})";
    int i,size;
    
    size=s.length();
    
    for (i=0;i<size;i++)
    {
     if (open.contains(""+s.charAt(i)))
      {
          parse=parse+s.charAt(i);
      }
      else
      {
          if (close.contains(""+s.charAt(i)))
           {
            if (parse.length()==0) return(false);   
            if ((close.indexOf(s.charAt(i)))!=open.indexOf(parse.charAt(parse.length()-1))) return(false);
            parse=parse.substring(0,parse.length()-1);
           }
      }
    }
 
    if (parse.length()==0) return(true);
    return(false);
 }
}

----------------------------------------------------------------

bool isValid(char* s) {

    char parse[1000];
    
    
    int i,j,size;
    bool status=false; 
    j=0;
    size=strlen(s);
 
    for (i=0;i<size;i++)
    {
     if ((s[i]=='(') || (s[i]=='[') || (s[i]=='{'))
      {
          parse[j]=s[i];
          j++;
      }
      else
      {  
          j--;
          if (parse[j]=='(')
           {
               if (s[i]!=')') return(status);
           }
          else
           {
            if (parse[j]=='[')
             {
               if (s[i]!=']') return(status);
             }
            else /* parse[j]=='{' */
             {
                if (s[i]!='}') return(status);
             }
           }
           
       }
      
     }
     if (j==0) status=true;
     return(status);
}

================================================================================================================================================

21. Merge Two Sorted Lists

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */

public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        
        if ((l1==null) && l2==null) return (null);
        
        if (l1==null) return (l2);
        
        if (l2==null) return (l1);
        
        ListNode r;
        
        if (l1.val > l2.val)
         {
          r=mergeTwoLists(l1,l2.next);
          l2.next=r;
          r=l2;  
         }
        else
         {
          r=mergeTwoLists(l1.next,l2);
          l1.next=r;
          r=l1;    
         }
        return(r);
    }
}

================================================================================================================================================

22. Generate Parentheses

class Solution {
    public List<String> generateParenthesis(int n) {
        
        List<String> r = new ArrayList<>();
        possibcomb(r,"",n,n);
        return(r);
    }
    
  void possibcomb (List<String> r, String x, int op, int cl)
   {
    if (cl==0) return;                  /* 0 -> No string added */
    if (op==cl)                         /* When open=close, we should open */ 
     possibcomb (r,x+"(",op-1,cl);
    else
     {
      if (op>0)                         /* When not, both options are ok, open or close */
       {
        possibcomb (r,x+"(",op-1,cl);
        possibcomb (r,x+")",op,cl-1);  
       }   
      else
       {                
        if (cl>1)                      /* Unless there is no open, in that case close */
         possibcomb (r,x+")",op,cl-1);
        else
         {    
          r.add(x+")");                /* When last close is available, add to list */
         }
       }
     }
     return; 
   }  
}


================================================================================================================================================

24. Swap Nodes in Pairs

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        
        ListNode p=head;
        ListNode r=head;
        
        
        if ((p!=null) && (p.next!=null)) r=p.next;
        
        while ((p!=null) && (p.next!=null))
         {
          ListNode psave=p;  
          ListNode pnow=p;
          p=p.next;
          pnow.next=p.next;
          p.next=pnow;
          p=pnow.next; 
          if ((p!=null) && (p.next!=null)) psave.next=p.next;
         }
        return(r);
    }
}

================================================================================================================================================

26. Remove Duplicates from Sorted Array

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        
    int i=0,j=0, old=nums[0]-1;
        
    while (i<nums.size()) 
     {
      if (nums[i]!=old)
       {
        if (i!=j) nums[j]=nums[i];  
        old = nums[i];
        j++;
       }   
      i++;
     }  
    return(j);    
    }
};

================================================================================================================================================

27. Remove Element 

int removeElement(int* nums, int numsSize, int val) {
    
    int i,j;
    
    i=0;
    j=0;
    
    while (j<numsSize)
    {
        if (nums[j]==val)
         {
          j++;
         }
        else
         {
          nums[i]=nums[j];        
          i++;
          j++;
         }
         
         
    }
    return (i);
}

================================================================================================================================================

28. Implement strStr()  

int strStr(char* haystack, char* needle) {
    
    int i;
    
    
    if(strlen(haystack)<strlen(needle)) return(-1);
    
    
    for (i=0;i<=(strlen(haystack)-strlen(needle));i++)
    {
        
        if (strncmp(haystack+i,needle,strlen(needle))==0) return (i);
    }
    
    return(-1);
}

================================================================================================================================================

30. Substring with Concatenation of All Words 

public  class Solution {
        public  List<Integer> findSubstring(String s, String[] words) {

         int i,j,k, pr;

         String toFind;
         
         List<Integer> result=new ArrayList<Integer>();
         
         boolean found=false;
         
         int nwords=words.length;
         
         int swords=words[0].length();
         
         
         boolean ispart[] = new boolean[nwords];
         
         
         
         pr=0;
         
         if (nwords*swords>s.length()) return (result);   
         
         for (j=0;j<=(s.length()-nwords*swords);j++)
            {
             for (i=0;i<nwords;i++) ispart[i]=false; 
             for (k=0;k<nwords;k++)
              {
               toFind=s.substring(j+k*swords,j+swords*(k+1));
               found=false;
               for (i=0;i<nwords;i++) 
                {
                    
                  if ((!ispart[i]) && (toFind.equals(words[i])))
                  {
                      
                   ispart[i]=true;
                   found=true;
                   break;
                  }
                }
               if (!found) break;       
              }
              if (found)
               {
                result.add(pr,j);
                pr++;
               }
             }
             return(result);
     }
 }

----------------------------------------------------------------

// C solution using strstr, pointer and recursivity

/**
* Return an array of size *returnSize.
* Note: The returned array must be malloced, assume caller calls free().
*/
bool issub (char* s, char* strw, int lw)
{
  if (strncmp(s,strw,strlen(strw)-1)==0) return (true);   /* If strings match return true */
  char tosearch[lw+2];
  char *p;
  tosearch[lw+1]=0;
  tosearch[lw]='\t';
  strncpy(tosearch,s,lw);
  p=strstr(strw,tosearch);
   
  if (p==NULL) return(false);                 /* If is not a substring return false */
  while (*(p+lw+1)!=0)                        /* If is a substring, remove it from search and from string and do it again */
   {
    *p=*(p+lw+1);
    p++;
   }
  *p=0;
  p=s+lw; 
  return (issub(p,strw,lw));
} 


int* findSubstring(char* s, char** words, int wordsSize, int* returnSize) {
int lwords=strlen(words[0]);                          /* length of the words */
   
if (strlen(s)<lwords*wordsSize) return(NULL);          /* String should be greater than length of the words multiplied by number of words */
  
int* r;
r=(int *)malloc(strlen(s)-lwords*wordsSize+1);         /* Setting return array with largest possible size */
                                                       /* Using malloc to be able to return */
  
    
char strw[(lwords+1)*wordsSize+1];                     /* Template to search */
strw[(lwords+1)*wordsSize]=0;
char strwTemp[(lwords+1)*wordsSize+1];
  
int i,k;
char* p=strw;  
for (i=0;i<wordsSize;i++)                              /* Add all words to an unique string with line breaks */
{
  strncpy(p,words[i],lwords);
  p=p+lwords;
  *p='\t';
  p++;
}
i=0;
k=0;  
    
while (i<=strlen(s)-lwords*wordsSize)                  /* For every position of the string, check if is a substring */
{
  strcpy(strwTemp,strw);
  p=s+i;
  if (issub(p,strwTemp,lwords))                       /* If yes, mark */
  {
   r[k]=i;
   k++; 
  }
  i++;
} 

*returnSize=k;     
return(r);     
}


----------------------------------------------------------------
// Java Usando Hash Table

public  class Solution {
    
    
boolean issub (String s, Map<String, Integer> strw, int lw)
{
  if (strw.containsKey(s.substring(0,lw)))     /* If substring found update hash table */
   {
    int x=strw.get(s.substring(0,lw))-1;
    strw.put(s.substring(0,lw),x);
    if (x==0) 
     {
      strw.remove(s.substring(0,lw));  
      if (s.length()==lw) return(true);       /* If string is ending return true */
     } 
    return (issub(s.substring(lw),strw,lw));  /* If string not at end, call again for remaining */
   }
  return(false);                              /* If substring not found return false */
}    
    

    
    
public  List<Integer> findSubstring(String s, String[] words) {

List<Integer> r=new ArrayList<Integer>();
Map<String, Integer> strw = new HashMap<>();           /* Build hash table to search */
int i,lwords=words[0].length();                        /* length of the words */
   
if (s.length()<lwords*words.length) return(r);         /* String should be greater than length of the words multiplied by number of words */
 
for (i=0;i<words.length;i++)                           /* Add all words to an unique string with line breaks */
{
 if (strw.containsKey(words[i]))
  {
   int x=strw.get(words[i])+1;
   strw.put(words[i],x);  
  }
 else
  {
   strw.put(words[i],1);  
  }    
}

i=0;    
while (i<=s.length()-lwords*words.length)                  /* For every position of the string, check if is a substring */
{
  Map<String, Integer> strwTemp = new HashMap<>(strw);  
  if (issub(s.substring(i,i+lwords*words.length),strwTemp,lwords))  r.add(i);                     /* If yes, mark */
  i++;
} 

return(r);     
}
            
            
}








================================================================================================================================================

33. Search in Rotated Sorted Array  
 
public class Solution {
    public int search(int[] nums, int target) {

        int i=0;
        
        int part=0;
        
        while (i<nums.length)
        {
         if ((part==2) && (target < nums[i])) return(-1);    
         if ((part==1) && (nums[i]<nums[i-1])) part=2;  
         if((nums[i]>target) && (part==0)) 
          part=1;
         else
          if((nums[i]<target) && (part==0)) 
           part=2;
          else 
           if (nums[i]==target) return(i);
         i++;
        }
        
        return(-1);
    }
}

================================================================================================================================================

34. Search for a Range

class Solution {
    public int[] searchRange(int[] nums, int target) {
      
    int min=0;
    int max=nums.length-1;
    int i=0;
    int[] r=new int[2];    

    if (nums.length==0)    
      {
       r[0]=-1;
       r[1]=-1;  
       return(r); 
      }
    while (max-min>1)
     {
      i=(max+min)/2;  
      if (nums[i]==target) break;
      if (nums[i]<target)
       min=i;
      else
       max=i;   
     }
     if (nums[max]==target) i=max;
     if (nums[min]==target) i=min;
     if (nums[i]==target)
      {
       int j=i;
       while ((j>=0) && (nums[j]==target)) j--;
       r[0]=j+1;
       j=i;  
       while ((j<nums.length) && (nums[j]==target)) j++;
       r[1]=j-1;
      }
     else   
      {
       r[0]=-1;
       r[1]=-1;  
      }
     return(r); 
    }
}

================================================================================================================================================

36. Valid Sudoku

class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        
    int i,j,k,ii,jj;
        
    char line[9];    
        
    for (i=0;i<9;i++)
     { 
      k=0;  
      for (j=0;j<9; j++)
       {  
        line[k]=board[i][j];
        k++;
       }
      if (repeat(line)) return(false);  
     }  

    for (i=0;i<9;i++)
     { 
      k=0;  
      for (j=0;j<9; j++)
       {  
        line[k]=board[j][i];
        k++;
       }
      if (repeat(line)) return(false);  
     }  

    for (ii=0;ii<3;ii++)
     for (jj=0;jj<3;jj++)
      {   
       k=0;    
       for (i=0;i<3;i++)
        { 
         for (j=0;j<3; j++)
          {  
           line[k]=board[i+ii*3][j+jj*3];
           k++;
          }
        }       
      if (repeat(line)) return(false);  
     }
    return(true);    
  }
    
    
 bool repeat (char line[])
    {
      string x="";
      int i; 
      cout << x; 
      
      for (i=0;i<9;i++)
       {
          
        if ((line[i]>='0') & (line[i]<='9'))  
         {
          if (x.find(line[i])!=string::npos)
            {   
              cout << x;
              return(true);
            }    
          else
             x = x + line[i];   
         } 
       }
      return(false); 
    }   
};

================================================================================================================================================

43. Multiply Strings 

public class Solution {
    public String multiply(String num1, String num2) {
        
        String r="0",r2;
        
        int i,j,k,x;
        
        for (i=0;i<num1.length();i++)
         {
          for (j=0;j<num2.length();j++)
           {
            x=(num1.charAt(num1.length()-i-1)-'0')*(num2.charAt(num2.length()-j-1)-'0');
            String st="";
            if (x/10>0) st=st+(char)('0'+x/10);
            st=st+(char)('0'+x%10);
            r2=r.substring(r.length()-i-j);
            r=adds(r.substring(0,r.length()-i-j),st);
            r=r+r2;
           }          
         }
        while ((r.charAt(0)=='0') && (r.length()>1))
         {
          r=r.substring(1);
         }
        return(r);
    }
    
    public String adds(String num1, String num2)
    {
        int i,x,togo=0;
        String res="";
        String s,l;
        if (num2.length() > num1.length())
         {
          s=num1;
          l=num2;
         }
        else
         {
          s=num2;
          l=num1;
         }
        for (i=0;i<l.length();i++)
        {
         if (i<s.length())
          {
           x=s.charAt(s.length()-i-1)-'0'+l.charAt(l.length()-i-1)-'0'+togo;
           togo=x/10;
           res=(char)('0'+x%10)+res;
          }
         else
          {
           if (togo>0)
            {
             x=l.charAt(l.length()-i-1)-'0'+togo;
             togo=x/10;
             res=(char)('0'+x%10)+res;
            }
           else
            {
             res=l.substring(0,l.length()-i)+res;
             break;  
            }
            
          }
        }
        if (togo==1) res="1"+res;
        return(res);
    }
    
}

================================================================================================================================================

48. Rotate Image 

public  class Solution {
    public  void rotate(int[][] matrix) {



        int i=0;
        int j=0;
        int size;

        size=matrix.length;

        int[][] m=new int[size][size];


        for (i=0;i<size;i++)
        {
            for (j=0;j<size;j++)
            {
                m[j][size-i-1]=matrix[i][j];
            }
        }

        for (i=0;i<size;i++)
        {
            for (j=0;j<size;j++)
            {
                matrix[i][j]=m[i][j];


            }
        }

    }
}

-------------------------------------------------------------------------------

void rotate(int** matrix, int matrixRowSize, int matrixColSize) {
    
    int i=0;
    int j=0;
    
    int m[matrixRowSize][matrixColSize];
    
    for (i=0;i<matrixRowSize;i++)
    {
        for (j=0;j<matrixColSize;j++)
        {
            m[j][matrixColSize-i-1]=matrix[i][j];
        }
    }

    for (i=0;i<matrixRowSize;i++)
    {
        for (j=0;j<matrixColSize;j++)
        {
            matrix[i][j]=m[i][j];
        }
    }
}    

================================================================================================================================================

50. Pow(x, n)

class Solution {
public:

double myPow(double x, int n){
    
    int m;
    
    if (x==1)
       return(x); 
    
    if (n==0)
       return(1);
        
    if (n==1)
       return(x);
    
    if (n < 0) 
       { 
         x = 1/x; 
         m = -(n/2);
       } 
    else
       m = n/2;
        
    if ((n%2)==0)    
       return (myPow(x*x,m));
    else
       return (myPow(x*x,m)*x); 
        

}
};

// Less iterations, faster

class Solution {
public:

double myPow(double x, int n){
    
    int m,r;

    double pp;
    
    int factor = 16;
        
    if (x==1)
       return(x); 
    
    if (n==0)
       return(1);
        
    if (n==1)
       return(x);
    
    if ((n<factor) & (n>-factor))
       factor = 2;
    
    if (n < 0) 
       { 
         x = 1/x; 
         m = -(n/factor);
       } 
    else
       m = n/factor;
    
    pp = x*x;
    if (factor==16) pp = pp*pp*pp*pp*pp*pp*pp*pp;
    
    r = n%factor;    
    if ((r)==0)    
      {  
       return (myPow(pp,m));
      }
    else
     {
      if (r<0) r=-r;  
      return (myPow(pp,m)*myPow(x,r)); 
     }  
        

}
};

================================================================================================================================================

53. Maximum Subarray

int maxSubArray(int* nums, int numsSize) {
        
    int start=0;
    int end=numsSize-1;
    int r=0;
    int sum;
    int i;
    if (numsSize==0) return(0);
    if (numsSize==1) return(nums[0]);
    
    int max=nums[0];
    while ((start<=end) && (nums[start]<0)) 
     {
      if (nums[start]>max) max=nums[start];  
      start++;
     }
    if (start>end) return(max);    
    while ((end>=start) && (nums[end]<0)) 
     {
      if (nums[end]>max) max=nums[end];
      end--;
     }
    i=start;
    sum=0;
    max=0;    
    while (i<end)
     {
      sum=sum+nums[i];
      if (sum>max) max=sum;  
      i++;  
      if (sum<0) 
       {
        start=i;
        sum=0;  
       }   
      }   
    i=end;
    sum=0;
    while (i>start)
     {
      sum=sum+nums[i];
      if (sum>max) max=sum;  
      i--;  
      if (sum<0) 
       {
        end=i;
        sum=0;  
       }   
      }   
    while (start<=end) 
    {
     r=r+nums[start++];
    }    
    return (max>r ? max : r);
}
        
----------------------------------------------------------------------------------------------------

class Solution {
    public int maxSubArray(int[] nums) {
        
    int start=0;
    int end=nums.length-1;
    int r=0;
    int sum;
    int i;
    if (nums.length==0) return(0);
    if (nums.length==1) return(nums[0]);
    
    int max=nums[0];
    while ((start<=end) && (nums[start]<0)) 
     {
      if (nums[start]>max) max=nums[start];  
      start++;
     }
    if (start>end) return(max);    
    while ((end>=start) && (nums[end]<0)) 
     {
      if (nums[end]>max) max=nums[end];
      end--;
     }
    i=start;
    sum=0;
    max=0;    
    while (i<end)
     {
      sum=sum+nums[i];
      if (sum>max) max=sum;  
      i++;  
      if (sum<0) 
       {
        start=i;
        sum=0;  
       }   
      }   
    i=end;
    sum=0;
    while (i>start)
     {
      sum=sum+nums[i];
      if (sum>max) max=sum;  
      i--;  
      if (sum<0) 
       {
        end=i;
        sum=0;  
       }   
      }   
    while (start<=end) 
    {
     r=r+nums[start++];
    }    
    return (max>r ? max : r);
}
        
        
}
        



================================================================================================================================================

60. Permutation Sequence

public class Solution {
    public String getPermutation(int n, int k) {
        int i,j;
        int[] control=new int[n+1];
        String r="";
        for (i=0;i<n;i++) control[i]=i+1;
        k--;  /* 1st is 0, 2nd is 1 etc */
        while (n>0)                        /* First digit n possibilities, 2nd n-1 (n except previous),  n-2, n-3 ....*/
         {
          int fact=1;
          for (i=n;i>0;i--) fact=fact*i;   /* Calculate position of digit */
          r=r+control[k/(fact/n)];
          j=k/(fact/n);
          k=k%(fact/n);
          while (control[j]!=0)
           {
            control[j]=control[j+1];       /* Remove digit from next choices */
            j++;
           }
          n--; 
         }
         return(r);
    }
}

================================================================================================================================================

64. Minimum Path Sum

class Solution {
    public int minPathSum(int[][] grid) {
     
     int[][] soma=new int[grid.length][grid[0].length];
        
     int i,j;
        
     for (i=0;i<grid.length;i++)
      for (j=0;j<grid[0].length;j++)
       soma[i][j]=-1;   
        
     return mpsun(grid,0,0,soma);   
    }
    
    int mpsun (int[][] grid, int i, int j, int[][] s) {
        
    if (s[i][j]>=0) return(s[i][j]);
        
    int x=0,y=0,r=0;
      
    if ((i<grid.length-1) && (j<grid[i].length-1))
     {  
      x=mpsun(grid, i+1,j,s)+grid[i][j];
      y=mpsun(grid, i,j+1,s)+grid[i][j];
      r = ( x < y ? x : y);
     }
    else
     {   
      if ((i>=grid.length-1) && (j>=grid[i].length-1)) 
       r = grid[i][j];
      else
       {   
        if (i>=grid.length-1) 
         r = mpsun(grid, i,j+1,s)+grid[i][j];
        else
         r = mpsun(grid, i+1,j,s)+grid[i][j];
       }
     }
    s[i][j]=r;    
    return(r);    
  }      
        
}


================================================================================================================================================

69. Sqrt(x)

public class Solution{
    
    public int mySqrt(int x) {
        
        if (x==0) return(0);
        if (x<4) return(1);
        
        long i,max,min;
        
        min=0;
        max=x;
        i=(min+max)/2;

     while (max-min>1)
        {
         i=(min+max)/2;
         if (i*i==x) return((int)i);
         if (i*i>x) 
          max=i;
         else
          min=i;
        }    
        return((int)min);
    }
} 

================================================================================================================================================

73. Set Matrix Zeroes

public class Solution {
    public void setZeroes(int[][] matrix) {
        
        int i,j,k;
        
        List<Integer> zeroi = new ArrayList<>();
        List<Integer> zeroj = new ArrayList<>();
        
        
        for (i=0;i<matrix.length;i++)
         {
          for (j=0;j<matrix[i].length;j++)
           {
            if (matrix [i][j]==0)
             { 
              if (!zeroi.contains(i)) zeroi.add(i);
              if (!zeroj.contains(j)) zeroj.add(j);
                
             } 
           }   
         }   
        for (k=0;k<zeroi.size();k++)
         {
          i=zeroi.get(k);
          for (j=0;j<matrix[i].length;j++) matrix[i][j]=0;
         }   
        for (k=0;k<zeroj.size();k++)
         {
          j=zeroj.get(k);
          for (i=0;i<matrix.length;i++) matrix[i][j]=0;
         }   
    }
}

================================================================================================================================================

80. Remove Duplicates from Sorted Array II

class Solution {
    public int removeDuplicates(int[] nums) {
     
    if (nums.length<3) return(nums.length);
        
    int i,j,val;
    boolean rep=false;    
    i=1;
    j=1;
    val=nums[0];
    
    while (j<nums.length)
     {
      nums[i]=nums[j];  
      if (nums[j]==val)
       {
        if (!rep) 
        {   
         rep=true;
         i++;
        }  
       }
      else
       {
        val=nums[j];
        rep=false;
        i++;
       }
       j++; 
     }   
     return(i);   
    }
}


================================================================================================================================================
 
98. Validate Binary Search Tree

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        
        if (root==null) return(true);
        
        long[] temp = new long[2];
        temp[0]=root.val;
        temp[1]=root.val;
        
        return (isVBST(root,temp));        
        
    }
    
        
        public boolean isVBST(TreeNode root, long[]minmax) {
        
        if (root==null) return(true);    /* Trees with no branchs are BST */
            
        long max=root.val,min=root.val; 
        boolean rl,rr;    
            
        if (root.right!=null)             /* Return false if right branch is less than value or left branch is greater */    
         if (root.right.val <= root.val) 
          return(false);
         else
          max= root.right.val;            /* If not false, max and min are updated */  
        if (root.left!=null) 
         if (root.left.val >= root.val) 
          return(false);
         else
          min= root.left.val;  

        long[] mml = new long[2];             /* Prepare array for left and right search */
        long[] mmr = new long[2];    
            
        mml[0]=(min<minmax[0]) ? min : minmax[0];   /* Left min to root.val-1 */
        mmr[1]=(max>minmax[1]) ? max : minmax[1];   /* Right root.val+1 to max */
            long x=root.val;
        mml[1]=x-1;
        mmr[0]=x+1;    
            
        rl=isVBST(root.left,mml);                                /* Do the same with left and right branch */
         if ((rl==false) || (mml[1]>=root.val)) return(false);   /* They should also be BST */
        rr=isVBST(root.right,mmr);                               /* If not return false */   
         if ((rr==false) || (mmr[0]<=root.val)) return(false);   /* If return true, confirm if no value at left is greater than root.val */
                                                                 /* and no value at right is less than root.val */      
        if (mml[0]<minmax[0]) minmax[0]=mml[0];                  /* Update max and min to keep to upper branches */  
        if (mmr[1]>minmax[1]) minmax[1]=mmr[1];   
          
        return(true);        
        
    }
    
    
}

================================================================================================================================================

100. Same Tree

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


bool isSameTree(struct TreeNode* p, struct TreeNode* q){
    
    if ((p==NULL) & (q==NULL)) return(true);
    if ((p==NULL) | (q==NULL)) return(false);                                 
    
    if (p->val!=q->val) return(false);
    
    return ((isSameTree(p->left,q->left)) & (isSameTree(p->right,q->right)));

}

================================================================================================================================================

110. Balanced Binary Tree

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

int depth (struct TreeNode* root)
{
 if (root==NULL) return(0);   /* root null, 0 deep */
    
 if ((root->left==NULL) && (root->right==NULL)) return(1);  /* Left and Right null, deep 1 */
   
 int dl = depth(root->left);
 int dr = depth(root->right);
 
 if ((dl<0) || (dr<0)) return (-1);  /* subtree returned -1, return -1 */
    
 int r=dl;            /* Return the deeper value */
 if (dr>dl) r=dr;  
    
 return ((dl-dr<=1) && (dl-dr>=-1)) ? r+1 : -1;   /* if diff more than one, return -1 */
}

bool isBalanced(struct TreeNode* root) 
{
    int d =  depth (root);     /* Return how deep (and balanced root is */
    return (d<0) ? false : true;
}

================================================================================================================================================

118. Pascal's Triangle 

public class Solution {
    public List<List<Integer>> generate(int numRows) {
        
        int i,j;
        
        List<List<Integer>> r = new ArrayList<>();
  
        int prev_line[] = new int[numRows];
        int line[] = new int [numRows];
        
        for (i=1;i<=numRows;i++)
        {
         List<Integer> l = new ArrayList<>();
         line[0]=1;
         for (j=1;j<i-1;j++)
          {
           line[j]=prev_line[j-1]+prev_line[j];   
          }
         line[i-1]=1;
         for (j=0;j<i;j++)
          {
           prev_line[j]=line[j];
           l.add(line[j]);
          }
          r.add(l);
          /* l.clear();  */
          l=null; /* To release the memory used for l */
        }
        return(r);
    }
}

================================================================================================================================================

122. Best Time to Buy and Sell Stock II 

public class Solution {
    public int maxProfit(int[] prices) {
        
        int i,dif=0,profit=0;
        
        int min=-1;
        
        for (i=0;i<prices.length;i++)
        {
         if (min<0) 
          min=prices[i];
         else
          { 
           if (prices[i]>min+dif) dif=prices[i]-min; 
           if ((prices[i]<prices[i-1]) && (dif!=0))
            {
              profit=profit+dif;
              dif=0;
              min=prices[i];
            }
           if (prices[i]<min) min=prices[i];
          }
 
        }
        profit=profit+dif;
        return(profit);
    }
}

================================================================================================================================================

129. Sum Root to Leaf Numbers

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int sumNumbers(TreeNode root) {

    int r=0;
    
    if (root==null) return(0);
    
    if ((root.left==null) && (root.right==null))
     {
      return(root.val);
     }
    else
     {
      if (root.left!=null)  r=r+sumN(root.left,root.val);
      if (root.right!=null) r=r+sumN(root.right,root.val);
     }
     return(r);
    }
    
    
    public int sumN (TreeNode root, int valor)
    {
     if ((root.left==null) && (root.right==null))
      {
       return(valor*10+root.val);
      }
     else
      {
       if (root.left==null) return (sumN(root.right,valor*10+root.val));
       if (root.right==null) return (sumN(root.left,valor*10+root.val));
       return (sumN(root.right,valor*10+root.val) + sumN(root.left,valor*10+root.val));
      }
    }
}

================================================================================================================================================

130. Surrounded Regions

void mark(char** board, int boardRowSize, int boardColSize, int i, int j) {
    
    if (board[i][j]!='O') return;                        /* function to mark (change fromO to Z) if is O and have Z up,down,right or left */
    
    if ((board[i][j+1]!='Z') && (board[i+1][j]!='Z') && (board[i-1][j]!='Z') && (board[i][j-1]!='Z')) return;
    
    board [i][j]='Z';
                                                         /* When marking, call function again to mark up,down,right and left if needed*/
    mark (board, boardRowSize, boardColSize, i,   j+1);
    mark (board, boardRowSize, boardColSize, i+1, j);
    mark (board, boardRowSize, boardColSize, i,   j-1);
    mark (board, boardRowSize, boardColSize, i-1, j);
    
    return;
    
}    
void solve(char** board, int boardRowSize, int boardColSize) {
    
    if ((boardRowSize<3) || (boardColSize<3)) return; 
    
    int i,j;
    
    
    i=0;                                                         /* Replace O by Z on edges i or j = 0 or size-1 */
    for (j=0;j<boardColSize;j++)
    {
     if (board[i][j]=='O') board[i][j]='Z';
    }
    j=boardColSize-1;
    for (i=0;i<boardRowSize;i++)
    {
     if (board[i][j]=='O') board[i][j]='Z';
    }
    i=boardRowSize-1;
    for (j=boardColSize-1;j>=0;j--)
    {
     if (board[i][j]=='O') board[i][j]='Z';
    }
    j=0;
    for (i=boardRowSize-1;i>=0;i--)
    {
     if (board[i][j]=='O') board[i][j]='Z';
    }
    
    for (i=1;i<boardRowSize-1;i++)                                             /* For each position, replace O by Z if needed */
     {
      for (j=1;j<boardColSize-1;j++)
       {
        mark (board, boardRowSize, boardColSize, i, j);  
       }   
     }   
    
    for (i=0;i<boardRowSize;i++)                                                /* Final adjust remaining O -> X and Z -> O */
    {
     for (j=0;j<boardColSize;j++)
      {
       if (board[i][j]=='O') board[i][j]='X'; 
       if (board[i][j]=='Z') board[i][j]='O';  
      }   
    }  
    
  return;
    
}    
 
================================================================================================================================================

134. Gas Station

class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        
        boolean lowpoint=false;
        int topdeficit=0;
        int extragas=0;
        int start=0;
        int i;
        
        for (i=0;i<gas.length;i++)
         {
          extragas=extragas+gas[i]-cost[i];               /* Keep gas credit */
          if ((extragas<0) && (extragas<topdeficit))      /* When down, below 0, get minimum */
           { 
            topdeficit=extragas;
            lowpoint=true;  
           }
          else
           {
            if ((lowpoint) && (gas[i]>cost[i]))           /* When minimum found, save start */
             {
              lowpoint=false;
              start=i;   
             }   
           }   
         }
       return (extragas>=0) ? start : -1;                 /* At the end, if there is credit is possible starting from minimum point */
  }
}

================================================================================================================================================

143. Reorder List 

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void reorderList(ListNode head) {

        ListNode p,p1=head,p2=head;
        
        /*  Find Center */
        
        while (p2!=null)
         {
          p2=p2.next;
          if (p2!=null) 
           { 
               p2=p2.next;
               p1=p1.next;
           }
         }
        if (p1!=null)
         {
             p2=p1.next;
             p1.next=null;
             p1=p2;
         }

/* print_cadeia(head);
print_cadeia(p1);*/

        /* Invert (half) list */

        ListNode p_prev=null;
        while (p1!=null)
        {
         ListNode p_next=p1.next;
         p1.next=p_prev;
         p_prev=p1;
         p1=p_next;
        }
        p1=p_prev;
        
/* print_cadeia(head);
print_cadeia(p1);*/

        /* Merge */
        p2=head;
        while ((p1!=null) && (p2!=null))
        {
            ListNode p2_next=p2.next;
            p2.next=p1;
            ListNode p1_next=p1.next;
            p1.next=p2_next;
            p2=p2_next;
            p1=p1_next;
        }

/* print_cadeia(head); */

}
    
void print_cadeia(ListNode p)
{
while (p.next!=null)
{
    System.out.print(p.val+" ");
    p=p.next;
}
System.out.println(p.val);
}
    
    
}

================================================================================================================================================

150. Evaluate Reverse Polish Notation 

public class Solution {
    public int evalRPN(String[] tokens) {
        Deque <Integer> p = new LinkedList<>();
        
        int i,temp;
        
        boolean isNumber;
        
        for (i=0;i<tokens.length;i++)
        {
         isNumber=true;
         if  (tokens[i].equals("+"))
         {
          temp=p.removeFirst();
          temp=p.removeFirst()+temp;
          p.addFirst(temp);
          isNumber=false;
         }
         if  (tokens[i].equals("-"))
         {
          temp=p.removeFirst();
          temp=p.removeFirst()-temp;
          p.addFirst(temp);
          isNumber=false;
         }
         if  (tokens[i].equals("*"))
         {
          temp=p.removeFirst();
          temp=p.removeFirst()*temp;
          p.addFirst(temp);
          isNumber=false;
         }
         if  (tokens[i].equals("/"))
         {
          temp=p.removeFirst();
          temp=p.removeFirst()/temp;
          p.addFirst(temp);
          isNumber=false;
         }
         if (isNumber)
          {
           p.addFirst(Integer.parseInt(tokens[i]));  
          }
        }
        return (p.peekFirst());
    }
}

================================================================================================================================================

155. Min Stack  

/* public class MinStack {
    long min;
    Stack<Long> stack;

    public MinStack(){
        stack=new Stack<>();
    }
*/
public class MinStack {

    Deque <Integer> stack;
    Deque <Integer> minstack;
    
    /** initialize your data structure here. */
    public MinStack() {
        /* Create two stacks, 1 for min */ 
        stack = new LinkedList<>(); 
        minstack = new LinkedList<>(); 
        
    }
    
    public void push(int x) {
        /* If x < min push x to minstack, if not push min */
        
        int min=x;
        stack.addFirst(x);
        if (!minstack.isEmpty()) min = getMin();
        if (x < min)  min =x;
        minstack.addFirst(min);
        
    }
    
    public void pop() {
        /* Get and remove last value from stack and min stack */
        minstack.removeFirst();
        stack.removeFirst();
    }
    
    public int top() {
        /* Get last value from stack */
        return (stack.peekFirst());
    }
    
    public int getMin() {
        /* Get last value from min stack */
        
        return (minstack.peekFirst());
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */


================================================================================================================================================

167. Two Sum II - Input array is sorted

public class Solution {
    public int[] twoSum(int[] numbers, int target) {
        
        Map<Integer, Integer> ts = new HashMap<>();
        
        int r[]=new int[2];
        
        int i;
        
        for (i=0;i<numbers.length;i++)
         {
          if (ts.containsKey(target-numbers[i]))
           {
            r[0]=ts.get(target-numbers[i]);
            r[1]=i+1;
            break;
           }
          ts.put(numbers[i],i+1); 
         }
        return(r);
    }
}

================================================================================================================================================

169. Majority Element

public class Solution {
    public int majorityElement(int[] nums) {
       
      Map<Integer, Integer> control = new HashMap<>();
      boolean found=false;
      int i=0,x=0;
         
      while (!found)
       {
        x=1;   
        if (control.containsKey(nums[i]))
         {
          x=control.get(nums[i]);
          x++;
         }
        control.put(nums[i],x);
        i++;
        if ((x*2)>nums.length) found=true;
       }
      return(nums[--i]);  
     }
}

================================================================================================================================================

204. Counting Primes

public class Solution {
    public int countPrimes(int n) {
        
        boolean x[]=new boolean[n];
        
        int i,t,cnt=0;
        
        for (i=0;i<n;i++) x[i]=true;
        
        for (i=2;i<n;i++)
         {
          if (x[i])
           {
            cnt++;
            t=i+i;
            while (t<n) 
             {
              x[t]=false;
              t=t+i;
             }
           }
         }
         
       return(cnt);    
    }
}

================================================================================================================================================

207. Course Schedule

public class Solution {
    
    Map<Integer, List<Integer>> cursos = new HashMap<>();
    
    public boolean canFinish(int numCourses, int[][] prerequisites) {

        int i,j,k,x;
        
        for (i=0;i<prerequisites.length;i++)        /* Creating hash table with courses with pre requisites */
         {
          if (!cursos.containsKey(prerequisites[i][0]))
            {
             List<Integer> temp = new ArrayList<Integer>();
             temp.add(prerequisites[i][1]);
             cursos.put(prerequisites[i][0],temp);
            }
           else
            {
             List<Integer> temp =cursos.get(prerequisites[i][0]);
             temp.add(prerequisites[i][1]);
             cursos.put(prerequisites[i][0],temp);
            }
         }
        int cstatus []=new int[numCourses];       /* Verify if each course pass in pre req test */
        for (i=0;i<numCourses;i++) cstatus[i]=0;
        for (i=0;i<numCourses;i++)
         {
          if (cstatus[i]==0)
           {
            if (cursos.containsKey(i))
             {
              if (!passC(i,cstatus)) return(false);     
             }
           }
         }
        return(true); 
    }

    Boolean passC(int n, int[] status)    
     {
      if (status[n]==1) return(false);
      status[n]=1;

      if (cursos.containsKey(n))   /* Not in has table, no pre, ok */
       {
        int i;
        List<Integer> temp = new ArrayList<Integer>();
        temp=cursos.get(n);
        for (i=0;i<temp.size();i++)  /* Verify pre of pre */
         {
          if (!passC(temp.get(i),status)) return(false);  /* If any not ok, return not ok (false) */
         }  
       }
      status[n]=2;   /* if all good, ok, true */
      return(true);
     }
    
}

================================================================================================================================================

210. Course Schedule II

// Best Solution using recursivity

class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        
    Map<Integer, List<Integer>> cursos = new HashMap<>();
    Map<Integer, Integer> rcursos = new HashMap<>();
        
        
    int i=0,j,k=0;
    
    int[] r=new int[numCourses];
    int[] rf=new int[0];
        
    for (i=0; i<prerequisites.length; i++)      /* First add all courses to a hash table */
     {
      List<Integer> temp = new ArrayList<>();  
      if (cursos.containsKey(prerequisites[i][0])) temp=cursos.get(prerequisites[i][0]);
      temp.add(prerequisites[i][1]);
      cursos.put(prerequisites[i][0],temp);  
     }
        
    for (i=0;i<numCourses;i++)
     {
      k=findpath(i, cursos, rcursos, r, k);
      if (k<0) return (rf);  
     }
    return(r);    
        
        
        
   }
    
   public int findpath(int i, Map<Integer, List<Integer>> cursos, Map<Integer, Integer> rcursos, int[] r, int k ) 
   {
    if (rcursos.containsKey(i))
     {
      if (rcursos.get(i)==-1) return(-1);  
      return(k);   
     }
    rcursos.put(i,-1);   
    List<Integer> temp = new ArrayList<>(); 
    if (!cursos.containsKey(i))
     {
      rcursos.put(i,1);   
      r[k]=i;
      k++;
      return(k);  
     }
    else   
     {   
      temp=cursos.get(i);
      int j;
      for (j=0;j<temp.size();j++)
       {
        k=findpath(temp.get(j), cursos, rcursos, r, k);
        if (k<0) return (-1);
       }
      cursos.remove(i);  
      rcursos.put(i,1);  
      r[k]=i;
      k++;  
      return(k);  
     }
   }   
}

--------------------------------------------------------------------------------------------------------------------

Other solution not using recursivity with O=N*N, slow when N increases

class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        
    Map<Integer, List<Integer>> cursos = new HashMap<>();
    Map<Integer, Integer> rcursos = new HashMap<>();
        
        
    int i=0,j,k=0;
    
    int[] r=new int[numCourses];
        
    boolean reducing=true;    
        
    for (i=0; i<prerequisites.length; i++)      /* First add all courses to a hash table */
     {
      List<Integer> temp = new ArrayList<>();  
      if (cursos.containsKey(prerequisites[i][0])) temp=cursos.get(prerequisites[i][0]);
      temp.add(prerequisites[i][1]);
      cursos.put(prerequisites[i][0],temp);  
     }
        
        
        
    while (reducing)                          /* While is possible to remove courses from hash table */
     {
      reducing=false;
      for (i=0; i<numCourses; i++)           /* For every course with pre req ... */
       if (!rcursos.containsKey(i))   
       {
        List<Integer> temp = new ArrayList<>();  
        if (cursos.containsKey(i))
         {   
          temp=cursos.get(i);  /* Get list of pre req */
          j=0;
          while (j<temp.size())                         /* Remove all pre reqs without pre req adding to result */
           {
             if (!cursos.containsKey(temp.get(j)))
              {
               if (!rcursos.containsKey(temp.get(j)))
                {
                 r[k]=temp.get(j);
                 k++;
                 rcursos.put(temp.get(j),1);  
                }   
               temp.remove(j);
              }  
             else
              j++;   
           }
          if (temp.size()==0)                 /* If at the end no pre req anymore, add to result to and remove course from prereq */
           {
            if (!rcursos.containsKey(i))
             {
              r[k]=i;
              k++;  
              rcursos.put(i,1);  
             }  
            cursos.remove(i);
            reducing=true;
           }
         }
        else
         {
          if (!rcursos.containsKey(i))
           {
            r[k]=i;
            k++;  
            rcursos.put(i,1);  
           }  
         }   
       }  
     }
     if (k==numCourses) return(r);
     int[] rf=new int[0]; 
     return(rf);   
   }
}

================================================================================================================================================

217. Contains Duplicate  

public class Solution {
    public boolean containsDuplicate(int[] nums) {
        
       Map<Integer, Integer> ns = new HashMap<>();
       
       int i;
       
       for (i=0; i< nums.length; i++)
        {
         if (ns.containsKey(nums[i]))
          return (true);
         else
          ns.put(nums[i],i);
        }
        return(false);
    }
}

================================================================================================================================================

219. Contains Duplicate II 


public class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        
        Map<Integer, Integer> v = new HashMap<>();
        
        int i,x;
        
        for (i=0;i<nums.length;i++)
         {
          if (v.containsKey(nums[i]))
           {
            x=v.get(nums[i]);
            if ((i-x)<=k) return(true);
            v.put(nums[i],i);
           }
          else
           v.put(nums[i],i);
         }
        return(false); 
    }
}

================================================================================================================================================

220. Contains Duplicate III

public class Solution {
    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
    
    int i,j;
    int x=nums.length;
    int base=1;
    
    if (nums.length<2) return(false); /* Two distincts only if there is two */
    
    while (x>0)             /* Index -> Decimal */
     {
      x=x/10;
      base=base*10;
     }
    
    double[] numpos = new double [nums.length];  /* Store nums and index */
    
    for (i=0;i<nums.length;i++) 
     {
      numpos[i]=(nums[i]>=0) ? (double)nums[i]+(float)i/base : (double)nums[i]-(double)i/base;
     }
     
    Arrays.sort(numpos);   /* Sort to order by value */
    
    for (i=0;i<nums.length-1;i++) 
     {
         j=i;     /* For each value try to find other values in range */
         while ((j<nums.length-1) && (Math.abs((long)numpos[i]-(long)numpos[j+1])<=t))
          {       /* if they meet the index distance return true */
           if (Math.round(Math.abs((numpos[i]-(int)(numpos[i]))-(numpos[j+1]-(int)numpos[j+1]))*base)<=k) return(true);
           j++;
          }
     }
    
    return(false);
   }
}

================================================================================================================================================

221. Maximal Square

public class Solution {
    public int maximalSquare(char[][] matrix) {
        
    int i,ii,j,jj,cnt,max=0;
    boolean isbox,loopend;
    
    for (i=0;i<matrix.length;i++)       /* For every line */
     {
      cnt=0;     
      for (j=0;j<matrix[i].length;j++)   /* and every row */
       {
        if (matrix[i][j]=='0')           /* When 0, reset word count */  
         cnt=0;
        else 
         {
          cnt++; 
          if ((cnt>max) && (cnt<=i+1))    /* When N '1s' are found check if there is a box above */
           {
            isbox=true;
            ii=0;
            jj=0;
            loopend=false;
            while ((isbox) && (!loopend))
             {
              if (matrix[i-ii][j-jj]=='0') 
               isbox=false;
              jj++;
              if (jj==cnt)
               {
                jj=0;   
                ii++;
                if (ii==cnt) loopend=true;
               }
             }
            if (isbox)                     /* If  box update Max */
             {
              max=cnt;
             }
            else                           /* If not reduce counter and continues */
             cnt--;
           }
         }
       }
     }
    return(max*max); 
   }
}

================================================================================================================================================

226. Invert Binary Tree

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root==null) return (root);
        TreeNode temp=root.left;
        root.left=root.right;
        root.right=temp;
        invertTree(root.left);
        invertTree(root.right);
        return(root);
        
        
    }
}

================================================================================================================================================

229. Majority Element II 

public class Solution {
    public List<Integer> majorityElement(int[] nums) {
        
        Map<Integer, Integer> control = new HashMap<>();
        
        List<Integer> r=new ArrayList<>();
        
        int i,x;
        
        for (i=0;i<nums.length;i++)
         {
          if (control.containsKey(nums[i]))
           {
            x=control.get(nums[i]);
            if (x>0)
             {
              if ((x+1)>(nums.length/3)) 
               {
                r.add(nums[i]); 
                control.put(nums[i],-1);
               }
              else
               control.put(nums[i],x+1);
             }
           }
          else
           {
            if (1>(nums.length/3)) 
             {
              r.add(nums[i]); 
              control.put(nums[i],-1);
             }
            else
             control.put(nums[i],1);
           }
         }
       return (r);
    }
}

================================================================================================================================================

231. Power of Two 

public class Solution {
    public boolean isPowerOfTwo(int n) {
        int x,c=0;
        
        for (x=1;(x>0)&&(n>0);x=x<<1)
        {
         if ((n&x)!=0) c++;
         if (c==2) return (false);
        }
        return (c==1) ? true : false;  
        
/* Solution using hashmap */        
        
/* Map<Integer,Integer> power2 = new HashMap<>();  
int x=1;
while ( (x>0) && (!power2.containsKey(n)) )
 {
  power2.put(x,x);
  x=x<<1;
 }
return(power2.containsKey(n)); */
        
    }
}

================================================================================================================================================

235. Lowest Common Ancestor of a Binary Search Tree

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if ((p.val<root.val) && (q.val<root.val)) return(lowestCommonAncestor(root.left,p,q));
        if ((p.val>root.val) && (q.val>root.val)) return(lowestCommonAncestor(root.right,p,q));
        return(root);
    }
}
================================================================================================================================================

237. Delete Node in a Linked List

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
void deleteNode(struct ListNode* node) {
    struct ListNode* x;
    
    x=node->next;
    while (x->next!=NULL)
    {
     node->val=x->val;
     node=node->next;   
     x=x->next;   
    }
   node->val=x->val;
   node->next=NULL; 
   return; 
}

-----------------------------------------------------------

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        if (node.next==null) return;
        ListNode x=node.next;
        node.val=x.val;
        if (x.next==null)            
         node.next=null;
        else
         deleteNode(x);
        return;
    }
}


================================================================================================================================================

240. Search a 2D Matrix II

class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        
    int n=matrix.length;                // Returning false if empty
    if (n==0) return (false);    
    int m=matrix[0].length;
    if (m==0) return (false);    

    return(findMatrix(matrix, target, 0, m-1, 0, n-1));    // If not resolve
        
}

public boolean findVector(int[][] m, int target, int x0, int x1, int y0, int y1) {
    if (x1==x0)                                    // When 1 column, resolve as vector finding y ...
     {
      if (y1<y0) return(false);
      int pos=(y0+y1)/2;  
      if (m[pos][x0]==target) return(true);
      if (m[pos][x0]>target) return (findVector(m,target,x0,x1,y0,pos-1));
      return (findVector(m,target,x0,x1,pos+1,y1));     
     }   
    else                                             // or x
     {
        
      if (x1<x0) return(false);
      int pos=(x0+x1)/2; 
      if (m[y0][pos]==target) return(true);
      if (m[y0][pos]>target) return (findVector(m,target,x0,pos-1,y0,y1));
      return (findVector(m,target,pos+1,x1,y0,y1));
     }       
}
    
public boolean findMatrix(int[][] matrix, int target, int x0, int x1, int y0, int y1) {    

    
int m=x1-x0+1;      // Calculate width and height of matrix to process
int n=y1-y0+1;

if ((m==1) || (n==1)) return(findVector(matrix,target,x0,x1,y0,y1));  // when 1 line or 1 column, resolve as vector 

if (m==2) return(findVector(matrix,target,x0,x0,y0,y1) | findVector(matrix,target,x1,x1,y0,y1)); // when 2, resolve as 2 vectors
if (n==2) return(findVector(matrix,target,x0,x1,y0,y0) | findVector(matrix,target,x0,x1,y1,y1));    
    
int i,j,k,previousi=0,previousj=0;                // If 3 or more find the nearest in diagonal, breaking in 2 sub matrix

i=0;             
j=0;
k=0;   
        
if (matrix[i+y0][j+x0]==target) return(true); 
if (matrix[y0+n-1][x0+m-1]==target) return(true);         
if (matrix[i+y0][j+x0]>target) return(false); 
if (matrix[y0+n-1][x0+m-1]<target) return(false);         

while ((i<n) && (j<m) && (matrix[i+y0][j+x0]<target))
 {    
  previousi=i;    
  previousj=j;
  k++;  
  if (n>m)
   {
    j++;
    i=k*(n-1)/(m-1);
   }
  else
   {
    i++;
    j=k*(m-1)/(n-1);
   }   
 }  
    
if (matrix[i+y0][j+x0]==target) return(true); 
    
return (findMatrix(matrix, target, j+x0, x1, y0, y0+i-1) | findMatrix(matrix, target, x0, previousj+x0, previousi+y0+1, y1));    

}
    
}

================================================================================================================================================

242. Valid Anagram

class Solution {
    public boolean isAnagram(String s, String t) {
        
        int[] contr = new int['z'-'a'+1];
        
        int sz;
        
        if ((sz=s.length())!=t.length()) return(false);
        
        int i;
        
        for (i=0;i<sz;i++) contr[s.charAt(i)-'a']++;
        for (i=0;i<sz;i++) if ((--contr[t.charAt(i)-'a'])<0) return(false);  
        return(true);
         
    }
}

================================================================================================================================================

258. Add Digits

int ad (int num)
{
 int s=0;
 while (num>0)
  { 
   s=s+num%10;
   num=num/10;  
  }
 return(s);   
}    

int addDigits(int num) {
    while (num>=10) num=ad(num);
    return(num);
}

================================================================================================================================================

283. Move Zeroes 

void moveZeroes(int* nums, int numsSize) {
    
    int i,j;
    
    i=0;
    j=0;
    
    while (j<numsSize)
    {
        if (nums[j]==0)
         {
          j++;
         }
        else
         {
          if (i!=j) nums[i]=nums[j];        
          i++;
          j++;
         }
    }
    for (;i<numsSize;i++) nums[i]=0;
    return;
}


================================================================================================================================================

292. Nim Game

public class Solution {
    public boolean canWinNim(int n) {
        if (n>0)
         {
          if (n%4!=0) return (true);
         }
        return (false);
    }
}
==============================================================================================================================================-=

319. Bulb Switcher

public class Solution {
    public int bulbSwitch(int n) {
        
        return ((int)Math.sqrt(n));
        
    }
}

==============================================================================================================================================-=

322. Coin Change

public class Solution {
    public int coinChange(int[] coins, int amount) {
        int n=0,v=0,tmp,i,j;
        for (i=0;i<coins.length-1;i++)
         {
          for (j=0;j<coins.length-1-i;j++)
           {
            if (coins[j+1]>coins[j])
             {
              tmp=coins[j];
              coins[j]=coins[j+1];
              coins[j+1]=tmp;
             }
           }
         } 
    return (calcChange(coins, amount, 0));   
    }
    
int calcChange(int coins[], int amount, int start)
{
 int i,r=-1,min=-1;    
 if (amount==0) return (0);
 if (amount<coins[coins.length-1]) return (-1);
 for (i=start;i<=coins.length-1;i++)
  {
   if (amount==coins[i]) return(1);  
  }
 for (i=start;i<=coins.length-1;i++)
  {
   if (amount>coins[i])
    {
     if (((min==-1) || (min>((amount-coins[i])/coins[i])))) r=calcChange(coins, amount-coins[i],i);
     if ((r!=-1) && ((min==-1) || (min>r+1))) min = r+1;
    }
  }
  return(min);    
 }
}

---- Faster and simple solution in C --------------------------------------------------------------------

int coinChange(int* coins, int coinsSize, int amount) 
{
 int control[amount+1];
 int i,j;
 
 if (amount==0) return(0);

 control[0]=0;
 for (i=1;i<=amount;i++) control[i]=-1;   /* Start all values = -1, not possible */ 

 for (i=0;i<coinsSize;i++)  /* For every coin */
  {
   j=0;
   while (j+coins[i]<=amount)  /* Set possible amounts with this coin (and previous coins) according */
    {
     if (control[j]!=-1) 
      {
       if ((control[j+coins[i]]<0) || (control[j+coins[i]]>control[j]+1)) control[j+coins[i]]=control[j]+1;      
      }
     j++;
    }
  }
 return(control[amount]); /* Return minimum coins for the amount */
}

================================================================================================================================================

332. Reconstruct Itinerary

--------------------------------- Recursive solution -----------------------------------


public class Solution {
    public List<String> findItinerary(String[][] tickets) {
        
        Map<String, List<String>> tck = new HashMap<>();
        
        int i;
        String from, to;
        
        for (i=0;i<tickets.length;i++)                        /* Added fligts to hash table */
         {
          from=tickets[i][0];
          to=tickets[i][1];
          List<String> temp=new ArrayList<>();
          if (tck.containsKey(from)) temp=tck.get(from);
          temp.add(to);
          Collections.sort(temp);
          tck.put(from,temp);
         }
        List<String> r=new ArrayList<>();                     /* Prepare list for result */
        r=findIt("JFK",tck);
        Collections.reverse(r);                               /* Invert result to get right sequence */
        return(r);
        
    }
    
public List<String> findIt(String from, Map<String, List<String>> tck)  {  
    
        String to,fr;
        int i;
    
        List<String> r=new ArrayList<>();                           /* Prepare return */
        if (tck.containsKey(from))                                  /* If from is not in the list, return null */
         {
          List<String> temp=new ArrayList<>();
          Map<String, List<String>> tck2 = new HashMap<>(tck);      /* Create new instance to interact */
          temp=tck2.get(from);
          if (temp.size()==1)                                       /* If only one To, used it */
           {
            to=temp.get(0);   
            tck2.remove(from);
            if (tck2.size()>0)                                     /* If not last flight, add this one and get the remaining sequence */
             {   
              r = findIt(to, tck2);
              if (r.size()!=0)
               {
                r.add(from);
                return(r); 
               }
             }
            else                                                    /* If last one, return inverted */
             {
              r.add(to);
              r.add(from);
              return(r);  
             } 
            }   
          else                                                      /* If more than one To, try each one */
           {
            int j;   
            int count=temp.size();  
            for (j=0;j<count;j++) 
             {
              to=temp.get(0);
              temp.remove(to);
              if (temp.size()==0) 
               tck2.remove(from);
              else
               tck2.put(from,temp);
              r=(findIt(to, tck2));
              if (r.size()!=0)
               {
                 r.add(from);
                 return(r); 
               }
              temp.add(to);                                        /* If does not work, return previous trial before try next one */
              tck2.put(from,temp); 
             }
           }
          }
   return(r);     
 }
 
}

--------------------------------- Another solution using Stack -----------------------------------

public class Solution {
    public List<String> findItinerary(String[][] tickets) {
        
        Map<String, List<String>> tck = new HashMap<>();
        List<String> r=new ArrayList<>();  
        
       
        int [][] contr = new int [tickets.length][3];
        int i=0,pos=0;
        String from, to;
        
        for (i=0;i<tickets.length;i++)                        /* Added fligts to hash table */
         {
          from=tickets[i][0];
          to=tickets[i][1];
          List<String> temp=new ArrayList<>();
          if (tck.containsKey(from)) temp=tck.get(from);
          temp.add(to);
          Collections.sort(temp);
          tck.put(from,temp);
         }
        from="JFK";
        while (tck.size()>0)
         {   
          if (tck.containsKey(from)) 
           {   
            r.add(from);
            List<String> temp=new ArrayList<>();
            temp=tck.get(from);
            if (temp.size()==1)                                       /* If only one To, use it */
             {
              to=temp.get(0);   
              tck.remove(from);
              if (tck.size()==0)                                     /* If not last flight, add this one and get the remaining sequence */
               {  
                r.add(to);
                return(r);  
               }
             }
            else                                                     /* If more than one, add to a stack */
             {
              Collections.sort(temp);  
              to=temp.get(0);
              temp.remove(0);  
              tck.put(from,temp); 
              contr[pos][0]=r.size()-1;
              contr[pos][1]=0;
              contr[pos][2]=temp.size();  
              pos++;
             }
            from=to;  
           }
          else                                                       /* When not found before ending, use stack to try another way */
           {
            r.add(from);  
            i=r.size()-1;
            from="";
            to="";  
            while (i>=contr[pos-1][0])
             {
              from=r.get(i);
              r.remove(i);
              if ((from.length()!=0) && (to.length()!=0)) 
               {   
                List<String> temp=new ArrayList<>();
                if (tck.containsKey(from)) temp=tck.get(from);
                temp.add(to);
                tck.put(from,temp);
               }
              to=from;  
              i--;
             }
            r.add(from);  
            contr[pos-1][1]++;
            List<String> temp=new ArrayList<>();
            if (tck.containsKey(from)) temp=tck.get(from); 
            Collections.sort(temp);
            to=temp.get(contr[pos-1][1]);
            temp.remove(contr[pos-1][1]);
            if (contr[pos-1][1]==contr[pos-1][2]) pos--;  
            tck.put(from,temp);
            from=to;  
           }  
        }
       return(r); 
    } 
}   

================================================================================================================================================

334. Increasing Triplet Subsequence

class Solution {
    public boolean increasingTriplet(int[] nums) {
        
        int contr=0; 
        int mins[] = new int [3];
        
        int i;
        
        for (i=0;i<nums.length;i++)
         {
          if (contr==0)       /* No min set yet, setting */
           {
            contr=1;
            mins[0]=nums[i];  
           }
          else
           {
            if (contr==1)    /* No 2nd min set yet, setting or updating min */
             {
              if (nums[i]<=mins[0]) 
               mins[0]=nums[i];
              else
               {
                contr=2;
                mins[1]=nums[i];  
               }   
             }
            else               /* Setting another min if value < min */      
             {
              if (contr==2)
               {
                if (nums[i]>mins[1]) return(true);
                if (nums[i]>mins[0])
                 mins[1]=nums[i];  
                else
                 {
                  if (!(nums[i]==mins[0]))
                  {   
                   contr=3;
                   mins[2]=nums[i];   
                  } 
                 }   
               }
              else
               {
                if (nums[i]>mins[1]) return(true); 
                if (nums[i]<=mins[2])
                 mins[2]=nums[i];                    /* Another min replace min when Another 2nd min is less */
                else
                 {
                  mins[0]=mins[2];
                  mins[1]=nums[i];
                  contr=2;  
                 }   
               }   
             }   
           }   
         }  
        return (false);
    }
}

================================================================================================================================================

336. Palindrome Pairs

public class Solution {


    public List<List<Integer>> palindromePairs(String[] words) {
        Map<String, List<Integer>> complements = new HashMap<>();
        
        int i,j,k;
        int dif_start;
        
        List<List<Integer>> r = new ArrayList<List<Integer>>();
        
        for (i=0; i<words.length;i++)            /* Add all words to a hash table */
        {
            if (!complements.containsKey(words[i])) /* If word is not repeated it's added as a new entry */
             {
              List<Integer> temp = new ArrayList<Integer>();
              temp.add(i);
              complements.put(words[i],temp);
             }
            else                                 /* If word is repeated it's added as a same entry adding sequence number to list */     
             {
              List<Integer> temp = new ArrayList<Integer>();
              temp = complements.get(words[i]); 
              temp.add(i);
              complements.put(words[i],temp);
             }
        }
        
        for (i=0; i<words.length;i++)
        {
         if ((isPalindrome(words[i])) && complements.containsKey(""))  
          {
            List<Integer> temp = new ArrayList<Integer>();
            temp = complements.get("");
            for (k=0; k<temp.size(); k++)
             {
                 if (i!=temp.get(k))
                  {
                   List<Integer> rtemp = new ArrayList<Integer>();
                   rtemp.add(i);
                   rtemp.add(temp.get(k));
                   r.add(rtemp);
                   List<Integer> rtemp2 = new ArrayList<Integer>();
                   rtemp2.add(temp.get(k));
                   rtemp2.add(i);
                   r.add(rtemp2);
                  }
             }
          }


         if (complements.containsKey(reverse(words[i]))) /* add i with found key to answer if not i */ 
          {
            List<Integer> temp = new ArrayList<Integer>();
            temp = complements.get(reverse(words[i]));
            for (k=0; k<temp.size(); k++)
             {
                 if (i!=temp.get(k))
                  {
                   List<Integer> rtemp = new ArrayList<Integer>();
                   rtemp.add(i);
                   rtemp.add(temp.get(k));
                   r.add(rtemp);
                  }
             }
          }
         
         for (j=1;j<words[i].length();j=j+1)    
          {
           if(isPalindrome(words[i].substring(0,words[i].length()-j)))  /* Trying to find palindromes to last letters */
            {
             if (complements.containsKey(reverse(words[i].substring(words[i].length()-j)))) /* add i with found key to answer if not i */
             {
              List<Integer> temp = new ArrayList<Integer>();
              temp = complements.get(reverse(words[i].substring(words[i].length()-j)));
              for (k=0; k<temp.size(); k++)
               {
                if (i!=temp.get(k))
                 {
                  List<Integer> rtemp = new ArrayList<Integer>();
                  rtemp.add(temp.get(k));
                  rtemp.add(i);
                  r.add(rtemp);
                 }
               }
             }
           }           
          if(isPalindrome(words[i].substring(j)))    /* Trying to find palindromes to first letters */
            {
             if (complements.containsKey(reverse(words[i].substring(0,j)))) /* add i with found key to answer if not i */ 
              {
               List<Integer> temp = new ArrayList<Integer>();
               temp = complements.get(reverse(words[i].substring(0,j)));
               for (k=0; k<temp.size(); k++)
                {
                 if (i!=temp.get(k))
                  {
                   List<Integer> rtemp = new ArrayList<Integer>();
                   rtemp.add(i);
                   rtemp.add(temp.get(k));
                   r.add(rtemp);
                  }
                }
              }
            }

         }
         
    }
    return(r);
}
    
 String reverse (String s)
  {
   int i;
   String r="";
   for (i=0;i<s.length();i++)
    {
     r=s.charAt(i)+r;         
    }
   return(r); 
  }
    
boolean isPalindrome (String s)
  {
   int i;
   
   for (i=0;i<s.length()-i;i++)
    {
     if(s.charAt(i)!=s.charAt(s.length()-i-1)) return(false);         
    }
   return(true); 
  }
    
}

================================================================================================================================================

337. House Robber III

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int rob(TreeNode root) {
     
     if (root==null) return(0);
     int x=robval(root);
     int y=rob(root.left)+rob(root.right);   
     return (x >= y ? x : y );   
    }
    
    int robval (TreeNode r)
    {
     if (r==null) return(0);
     int s=0;
     if (r!=null) s=s+r.val;
     if (r.left!=null)
     {   
      TreeNode t=r.left;
      if (t.left!=null)  s=s+rob(t.left);
      if (t.right!=null) s=s+rob(t.right);
     }   
     if (r.right!=null)
     {   
      TreeNode t=r.right;
      if (t.left!=null)  s=s+rob(t.left);
      if (t.right!=null) s=s+rob(t.right);
     }   
     return(s);   
    }    
}

================================================================================================================================================

342. Power of Four

public class Solution {
    public boolean isPowerOfFour(int num) {
       return (((num & (num-1))==0) && ((num & 0x55555555)!=0)) ? true : false;
    }
}

================================================================================================================================================

344. Reverse String

public class Solution {
    public String reverseString(String s) {

    int MAX = 1000;
    
    if (s.length() > MAX)   /* For long strings, break in two */
     return (reverseString(s.substring(s.length()/2))+reverseString(s.substring(0,s.length()/2)));
    else                    /* For normal string, revert */  
     return (s.length()<=1 ? s : s.charAt(s.length()-1)+reverseString(s.substring(1,s.length()-1))+s.charAt(0));
 }
}

================================================================================================================================================

367. Valid Perfect Square 

public class Solution {
    public boolean isPerfectSquare(int num) {

        if (num<2) return(true);
        
        int min = 0;
        int max = num;
        int t;
        
        while (max-min>1)
         {
          t=(min+max)/2;
          if ((num/t==t) && (num%t==0)) return(true);
          if (t>num/t) 
           max=t;
          else
           min=t;
         }
        return(false);
    }
}

================================================================================================================================================

374. Guess Number Higher or Lower   

/* The guess API is defined in the parent class GuessGame.
   @param num, your guess
   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
      int guess(int num); */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        
        int min=1, max=n, x=0, status=2;
        
        while (status!=0)
         {
          x=(max-min)/2+min;
          status=guess(x);
          if (status==1) 
            min=x+1;
           else
            max=x-1;
          } 
        return(x);
    }
}

================================================================================================================================================

376. Wiggle Subsequence

int wiggleMaxLength(int* nums, int numsSize) {
    
    if (numsSize==0)  return (numsSize);
    

    int i;
    int longest=1;
    int prev=nums[0];
    int lastmove=0;  //1 up, -1 down, 0 first time
    
    for (i=1;i<numsSize;i++)
     {
      if (lastmove==1)
       {
        if (nums[i]<prev) 
         {   
          longest++;
          lastmove=-1;
         }  
        prev=nums[i];   
       }
      else
       {
        if (lastmove==-1)
         {
          if (nums[i]>prev) 
           {   
            longest++;
            lastmove=+1;
           }
          prev=nums[i];  
         }   
        else // =0 first time 
         {
          if (nums[i]<prev) 
           {   
            longest++;
            lastmove=-1;
           }  
          if (nums[i]>prev) 
           {   
            longest++;
            lastmove=+1;
           }  
          prev=nums[i];   
         }
        }   
      }   
     return(longest);   
      
}
================================================================================================================================================

377. Combination Sum IV

// In C using recursivity

int cs4(int* nums, int numsSize, int target, int* rt) {    
     
    if (target<=0) return(0);               /* If negative or zero, not possible */
    if (numsSize==0) return(0);             /* If list is empty, not possible */ 
    if (rt[target]>=0) return (rt[target]); /* If this target was already calculate in preliminar iteraction, return */
        
    int i,r=0,j=0;
    int nums2[numsSize];
    for (i=0;i<numsSize; i++) if (target-nums[i]>=0) nums2[j++]=nums[i];  /* Create new array including only useful values */
    for (i=0;i<numsSize; i++)
     {
      if (target-nums[i]==0)                                      /* If value = target done */
        r++;
      else  
        r=r+cs4(nums2, j, target-nums[i], rt);                    /* If not try with target = target-value ... recursivity */
     }   
    rt[target]=r;                                                 /* At the end, before returning, keep result in case it is needed */
    return(r);
   }

int combinationSum4(int* nums, int numsSize, int target) {        /* Main program */
        int rt[target+1];                                         /* Create array to keep results */
        int i;
        for (i=0;i<=target;i++) rt[i]=-1;
        return (cs4(nums,numsSize,target,rt));                    /* Call function for the first time */
}

------------------------------------------------------------------------------------------

// In Java using Combination formula for repeated (N!/(A!*B!*C! ...). To avoid Overflow in Factorial calcs, Factorial was processed together with division

class Solution {
    public int combinationSum4(int[] nums, int target) {
        
    int pos=0,cnt=0,sum=0,ii,jj;    
    boolean end=false;
       
    for (ii=0,jj=0;ii<nums.length;ii++)              /* Filter array with only numbers <= target */
     {
      if (nums[ii]<=target) nums[jj]=nums[ii];
      jj++;  
     }   
        
    if (jj==0) return(0);    
    int[] mult=new int[jj];
        
    while (!end)
     {
      if (sum==target)                               /* if it is a selection that sum match use Combination formula */
       {
        int n=0,i,j=0,k,nfat,max=0,nmax=0;
        for (i=0;i<mult.length;i++) if (mult[i]!=0) n=n+mult[i];   /* Calc N */
        int[] todivide=new int[n];                                 
        for (i=0;i<mult.length;i++)
         {
          int x=mult[i];
          while (x>1)
           {
            todivide[j]=x;
            j++;  
            x--;  
           }
         }
        nfat=1;
        i=2;  
        while (i<=n)                                        /* To avoid overflow calc fatorial and divide at same time */
         {
          nfat=nfat*i;
          i++;  
          for (k=j-1;(k>=0) && (nfat>1) && (j>0);k--)
           {
            if (nfat%todivide[k]==0)
             {
              nfat=nfat/todivide[k];
              j--;
              if (j>=0) todivide[k]=todivide[j];
             }
           }   
         }
        cnt=cnt+nfat;                                      /* Add all possible combinations to result */
       }   
      mult[pos]++;                                         /* Find all possible cases to match target adding */
      sum=sum+nums[pos];  
      while (mult[pos]*nums[pos]>target)
       {
        sum=sum-mult[pos]*nums[pos];
        mult[pos]=0;
        pos++;
        if (pos==mult.length)                              /* When last numeber, done */
         { 
          end=true;
          break;
         }   
        mult[pos]++;
        sum=sum+nums[pos]; 
       }
      pos=0;
     }
    return(cnt);  
   }
}


================================================================================================================================================

389. Find the Difference  


public class Solution {
    public char findTheDifference(String s, String t) {
        
        int i;
        String temp;
        
        i=0;
        temp=t.substring(i,i+1);
        
        while (s.contains(temp))
        {
         s=s.substring(0,s.indexOf(temp))+s.substring(s.indexOf(temp)+1);
         i++;
         temp=t.substring(i,i+1);
        }
        return(t.charAt(i));

}
}


================================================================================================================================================

394. Decode String

public class Solution {
    public String decodeString(String s) {
        int i=0,k;
        char c;
        int rep=0;
        String strtotal="";
        String str="";
        String todecode="";
        boolean strb=false;
        while (i<s.length())
         {
          c=s.charAt(i);
          i++;
          if (c==']')
           {
            strb=false;
            for (k=0;k<rep;k++) strtotal=strtotal+str;
            rep=0;
            str="";
           }
          else
           if (c=='[')
            {
             strb=true; 
             str="";
            } 
           else
            {
             if ((c<'0') || (c>'9') && (strb))
              {
               str=str+c;   
              }
             if ((c>='0') && (c<='9') && (strb)) 
              {
               todecode=todecode+c;
               int j=1;  
               boolean firsttime=true;
               while (j>0)
                {
                 c=s.charAt(i);
                 i++;
                 if (c=='[')
                  {
                   if (firsttime)
                    firsttime=false;
                   else
                    j++;
                  }
                 if (c==']') j--;
                 todecode=todecode+c;
                }
               str=str+decodeString(todecode); 
               todecode="";
              }
             if ((c>='0') && (c<='9') && (!strb)) 
              {
               rep=rep*10+c-'0';   
              }
             if ((c<'0') || (c>'9') && (!strb))
              {
               strtotal=strtotal+c;   
              }
            }
         }
        return(strtotal); 
    }
}

================================================================================================================================================

400. Nth Digit 

public class Solution {
    public int findNthDigit(int n) {

    long i,pos;
    long dig;
    long ndigit=0;
    long pr_ndigit=0;
    long ldigits;
    
    long x=n;
    
    x++; /* Including zero */
    
    dig=0;
    ldigits=0;
    while (ndigit<x)    /* Calculating how many digits */
     {
      pr_ndigit=ndigit;      
      dig++;
      long tmp=(long)Math.pow(10,dig);
      ndigit=tmp*dig-ldigits;
      ldigits=ldigits+tmp;
     }
    ndigit=pr_ndigit;
    pos=ndigit-dig+1;
    
    if (pos<=0) pos=1;      /* Pointing to last number with 1 digit less */
    i=(long)Math.pow(10,dig-1)-1;

    i=i+(x-pos)/dig;             /* Find what nummer has the nth digit */
    pos=(x)-(x-pos)%dig; 
    pos=pos+dig-1;

    while (pos!=x)          /* Getting digit */
     {
      i=i/10;
      pos--;
     }
    i=i%10;
    
   return((int)i);
  }
}

================================================================================================================================================
401. Binary Watch

public class Solution {
    public List<String> readBinaryWatch(int num) {
         
        Map<Integer, List<Integer>> times = new HashMap<>();
        
        List<String> r= new ArrayList<>(); 
        
        int i,j,x,c;
        
        /* Create hashtable with number of bits X decimal number */
        for (i=0;i<60;i++)
         {
          x=i;
          c=0;
          while (x!=0)
           {
            c=c+(x&1);
            x=x>>1;
           }
          List <Integer> temp = new ArrayList<>(); 
          if (times.containsKey(c)) temp=times.get(c);
          temp.add(i);
          times.put(c,temp);
         }
        
        
        /* Find all possible case that matches num */
        
        for (i=0;i<4;i++)
         for (j=0;j<6;j++)
          {
           if ((i+j)==num)  /* When sum == num find all possible combinations */ 
            {
             List <Integer> tempi = new ArrayList<>(); 
             if (times.containsKey(i)) tempi=times.get(i);
             List <Integer> tempj = new ArrayList<>(); 
             if (times.containsKey(j)) tempj=times.get(j);
             int ii,jj;
             for (ii=0;ii<tempi.size();ii++)
              for (jj=0;jj<tempj.size();jj++)
               {
                if (tempi.get(ii)<12)
                 {
                  String str=""+tempi.get(ii)+":";
                  if (tempj.get(jj)<10) str=str+"0";
                  str=str+tempj.get(jj);
                  r.add(str);
                 }
               }
            }
          }
        return(r);  
          
    }
}


================================================================================================================================================

402. Remove K Digits

char* removeKdigits2(char* num, int k) {

    if (k==0) return (num);                 /* No number to remove, same string */
    if (k>=strlen(num)) return("0");        /* Removing all, zero */

    int i;
    int min=10;    
    int kmin;

    char* p;    

    char* buffer;
    buffer = (char *)malloc(strlen(num)+1-k);   /* Alloc area to retur */    

    for (i=0;i<=k;i++)                       /* Find minimun digit in first K */
     {
      if (num[i]-'0'<min) 
       {
        min=num[i]-'0';
        kmin=i;   
       }      
     }

    buffer[0]=num[kmin];                 /* Return the digit found + same function with how many digits are missing */ 
    int x=strlen(num+kmin+1);    
    if ((x>0) && (x>k-kmin))  
     {
      p=removeKdigits2(num+kmin+1, k-kmin);
      strcpy(buffer+1,p);    
     }       
    else
     buffer[1]=0;                      

    return (buffer);   
}                 
    
char* removeKdigits(char* num, int k) {
  
   char r[strlen(num)];               /* Main function calling the recursive function */
   char* p=r; 
   p=removeKdigits2(num, k);          /* Final result should not have 0 on left */
   while (*p=='0') p++;
   return(strlen(p)==0) ? "0" : p; 
}    
  

================================================================================================================================================

404. Sum of Left Leaves 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        
        int sum=0;
        if (root!=null)
         {
          if (root.right!=null) sum=sum+sumOfLeftLeaves(root.right);
          if (root.left!=null) 
           { 
             if ((root.left.left==null) && (root.left.right==null)) 
              sum=sum+root.left.val; 
             else
              sum=sum+sumOfLeftLeaves(root.left);
           }
         }

        return(sum);
    }
}

================================================================================================================================================

412. Fizz Buzz 

public class Solution {
    public List<String> fizzBuzz(int n) {
        
        int i;
        
        List<String> a = new ArrayList<>();
        
        String r="";
        for (i=1;i<=n;i++)
        {   
         r="";
         if (((i%5)*(i%3))!=0) r=r+i;
          else
         { 
          if (i%3==0) r=r+"Fizz";
          if (i%5==0) r=r+"Buzz";
         }
         a.add(r);
        }
        return(a);
        
    }
}
================================================================================================================================================

415. Add Strings 


public class Solution {
    public String addStrings(String num1, String num2) {
        
        String r="";
        
        int i=0,x;
        boolean vaium=false;
        
        while  ((i<num1.length()) || (i<num2.length()))
         {
          x=0;
          if (i<num1.length()) x=x+(num1.charAt(num1.length()-1-i))-'0';    
          if (i<num2.length()) x=x+(num2.charAt(num2.length()-1-i))-'0';    
          x= vaium ? x+1 : x ;
          r=(char)(x%10+'0')+r;
          vaium=(x/10!=0);
          i++;
         }
        return (vaium ? '1'+r : r);
        
        
    }
}


================================================================================================================================================

417. Pacific Atlantic Water Flow

// Not using reciprocity

class Solution {
    public List<int[]> pacificAtlantic(int[][] matrix) {
    
    List<int[]> r=new ArrayList();
        
    int m=matrix.length;
    if (m==0) return(r);   
    int n=matrix[0].length;               
        
    boolean [][] atl = new boolean [matrix.length][matrix[0].length];
    boolean [][] pac = new boolean [matrix.length][matrix[0].length];
        
    boolean equalok=false;    
    
    int i,j,max;
    
    for (i=0;i<m;i++)
     {
      max=-1;  
      j=0;  
      while ((j<n) && (matrix[i][j]>=max))  
       {
        max=matrix[i][j];
        pac[i][j]=true;
        j++;  
       }
     }    
    for (j=0;j<n;j++)
     {
      max=-1;  
      i=0;
      while ((i<m) && (matrix[i][j]>=max))  
       {
        max=matrix[i][j];
        pac[i][j]=true;
        i++;  
       }
     }
    for (i=0;i<m;i++)
     {
      max=-1;
      j=n-1;  
      while ((j>=0) && (matrix[i][j]>=max))  
       {
        max=matrix[i][j];
        atl[i][j]=true;
        j--;  
       }
     }    
    for (j=0;j<n;j++)
     {
      max=-1;
      i=m-1;  
      while ((i>=0) && (matrix[i][j]>=max))  
       {
        max=matrix[i][j];
        atl[i][j]=true;
        i--;  
       }
    }
   boolean reducing =true;
        
   while (reducing)
    {
     reducing=false;  
     for (i=0;i<m;i++)
      for (j=0;j<n;j++)
       {
        if (!(pac[i][j]))
         {
          boolean temp=false;  
          if ((!temp) && (i>=1)  &&  (pac[i-1][j]) && (matrix[i-1][j] <= matrix[i][j])) temp=true;
          if ((!temp) && (j>=1)  &&  (pac[i][j-1]) && (matrix[i][j-1] <= matrix[i][j])) temp=true;
          if ((!temp) && (j<n-1) &&  (pac[i][j+1]) && (matrix[i][j+1] <= matrix[i][j])) temp=true;
          if ((!temp) && (i<m-1) &&  (pac[i+1][j]) && (matrix[i+1][j] <= matrix[i][j])) temp=true;
          if (temp)
           {
            reducing=true;
            pac[i][j]=true;
           }   
         }   
       }   
     }
   
   reducing=true;     
   while (reducing)
    {
     reducing=false;  
     for (i=0;i<m;i++)
      for (j=0;j<n;j++)
       {
        if (!(atl[i][j]))
         {
          boolean temp=false;  
          if ((!temp) && (i>=1)  &&  (atl[i-1][j]) && (matrix[i-1][j] <= matrix[i][j])) temp=true;
          if ((!temp) && (j>=1)  &&  (atl[i][j-1]) && (matrix[i][j-1] <= matrix[i][j])) temp=true;
          if ((!temp) && (j<n-1) &&  (atl[i][j+1]) && (matrix[i][j+1] <= matrix[i][j])) temp=true;
          if ((!temp) && (i<m-1) &&  (atl[i+1][j]) && (matrix[i+1][j] <= matrix[i][j])) temp=true;
          if (temp)
           {
            reducing=true;
            atl[i][j]=true; 
           }   
         }   
       }   
    }       
        
        
   
   for (i=0;i<m;i++)
    for (j=0;j<n;j++)
     if (pac[i][j] && atl[i][j]) 
      {
       int []par = {i,j};  
       r.add(par);  
      }   
    return(r);  
  }      
}

------------------------------------------------------------------------------------------------------------------------------------------------

// Using reciprocity. Shorter and 3 times faster

class Solution {
    public List<int[]> pacificAtlantic(int[][] matrix) {
    
    List<int[]> r=new ArrayList();
        
    int m=matrix.length;
    if (m==0) return(r);   
    int n=matrix[0].length;    
        
    char [][] contr = new char [m][n];
    
    int i,j;
    
    for (i=0,   j=0;   i<m; i++) marksea('P',i,j,-1,matrix,contr);  
    for (i=0,   j=0;   j<n; j++) marksea('P',i,j,-1,matrix,contr);  
    for (i=0,   j=n-1; i<m; i++) marksea('A',i,j,-1,matrix,contr);  
    for (i=m-1, j=0;   j<n; j++) marksea('A',i,j,-1,matrix,contr);  

    for (i=0;i<m;i++)
     {    
      for (j=0;j<n;j++)
       {   
        if (contr[i][j]=='X')
         {   
          int []par = {i,j};  
          r.add(par);
         }
           
       }   
     }
          
    return(r);
  }
    
    void marksea(char c, int i, int j, int v, int[][] mat, char[][] contr) {
        
    if ((mat[i][j]<v) || (contr[i][j]==c) || (contr[i][j]=='X'))  return;
  
    if (contr[i][j]=='P')  
     contr[i][j]='X';
    else
     contr[i][j]=c;
        
    int m=mat.length;
    int n=mat[0].length;  
      
    if (i<m-1) marksea(c, i+1, j, mat[i][j], mat, contr);    
    if (i>0)   marksea(c, i-1, j, mat[i][j], mat, contr);    
    if (j<n-1) marksea(c, i, j+1, mat[i][j], mat, contr);    
    if (j>0)   marksea(c, i, j-1, mat[i][j], mat, contr);    

    return;  
  }      
}


================================================================================================================================================

419. Battleships in a Board 

public class Solution {
    public int countBattleships(char[][] board) {
        
    boolean track[]=new boolean [board[0].length];
    
    int i,j,cnt=0;
    
    for (i=0;i<track.length;i++) track[i]=false;
    
    for (i=0;i<board.length;i++)
     {
      for (j=0;j<board[i].length;j++)
       {
        if (board[i][j]=='X')
         {
          track[j]=true;
          if ((j>0) && (track[j-1])) track[j-1]=false; /* making long horizontal ships size 1 to not count more */
         }
        else
         {
          if (track[j])
           {
            track[j]=false;
            cnt++;
           }   
         }
       }
     }
    for (i=0;i<track.length;i++) if(track[i]) cnt++;
    return(cnt);
   }
}

================================================================================================================================================

435. Non-overlapping Intervals

/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public int eraseOverlapIntervals(Interval[] intervals) {
      
     int i,j,r=0;   
     long control[] = new long[intervals.length];
     
     int mask=1;
     int shift=1;   
     
     if (intervals.length<=1) return (0);   
       
     while (mask+1<=intervals.length)  /* Defining high and low bits according the length of intervals */
     {
      mask=(mask<<1)|1;
      shift++;    
     }  
        
    for (i=0;i<intervals.length;i++)    /* Using high bits to keep start and low bits to keep index during sort */
     {
      control[i]=(intervals[i].start<<shift) | i;
     } 
    Arrays.sort(control);               /* Sort is simple and fast using one column only */
    for (i=0;i<intervals.length;i++)    /* After sorting, only index is needed */
     {
      control[i]=control[i]&mask;
     }     
        
    int prevStart=intervals[(int)control[intervals.length-1]].start;    /* Going down, count how many intervals need to be removed */
    for (i=intervals.length-2;i>=0;i--)    
      {
       int item=(int)control[i];
       if (intervals[item].end > prevStart)
        {
         r++;   
        }
       else
        {
         prevStart=intervals[item].start;   
        }   
       }
   return(r);      
 }
}

================================================================================================================================================

437. Path Sum III 


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int pathSum(TreeNode root, int sum) {
         
        int r=0;
        if (root!=null)
         { 
          if (root.val==sum) r++;
          if (root.left!=null)  r=r+pathSum(root.left,sum)+startsum(root.left,sum-root.val);
          if (root.right!=null) r=r+pathSum(root.right,sum)+startsum(root.right,sum-root.val);
         }
        return (r);
    }
    
    public int startsum(TreeNode root, int sum)
    {
     int r=0;
     if (root.val==sum) r++;
     if (root.left!=null) r=r+startsum(root.left,sum-root.val);
     if (root.right!=null) r=r+startsum(root.right,sum-root.val);
     return(r);
    }
}

================================================================================================================================================

442. Find All Duplicates in an Array

class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        
    Map<Integer, Integer> processedNumbers = new HashMap<>();
    List<Integer> r = new ArrayList<>();  
    int i=0;
        
    for (i=0;i<nums.length;i++)
     {
      if (processedNumbers.containsKey(nums[i]))
       {
        r.add(nums[i]);  
       }
      else
       {
        processedNumbers.put(nums[i],i);  
       }   
     }   
    return(r);
    }
}

---------------------------------------------------------------------------------------------

==> Other solution using no extra memory (no hash table) and running faster 

class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        
   
    List<Integer> r = new ArrayList<>();  
    int i=0;
    int x,val;    
        
        
    while (i<nums.length)
     {
      val=nums[i]-1;  
      if ((val==i) || (val<0))
       {
        i++;
       }
      else
       {
        if (nums[val]!=nums[i])
         {   
          x=nums[val];
          nums[val]=nums[i];
          nums[i]=x;
         }
        else
         {
          r.add(val+1);   
          nums[i]=0;
          i++;
         }   
       }   
     }   
    return(r);
    }
}



================================================================================================================================================

448. Find All Numbers Disappeared in an Array

public class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        
        int i,j,x;
        
        
        for (i=1;i<=nums.length;i++)
        {
         if (nums[i-1]!=i)
          {
           j=nums[i-1]; 
           while (nums[j-1]!=j)
            {
             x=nums[j-1];
             nums[j-1]=j;
             j=x;
            }
          }
        }
        
        List<Integer> r = new ArrayList<Integer>();
        
        for (i=1;i<=nums.length;i++)
        {
         if (nums[i-1]!=i)
          {
           r.add(i); 
          }
        }
        
        return(r);
    }
}

================================================================================================================================================

451. Sort Characters By Frequency


char* frequencySort(char* s) {
    
    int i;
    
    int cnt[256];
    
    
   
    char* ss;
    ss = (char *)malloc(strlen(s)+1);

    unsigned char cmax=0;
    unsigned char cmin=255;

    i=0;
    int max=0;
    int v,k,j;
    
    for (i=0;i<256;i++) cnt[i]=0;
    
    i=0;
    while (s[i]!=0)
     {
      cnt[s[i]]++;
      v=cnt[s[i]];
      if (v>max) max=v; 
      if (s[i]>cmax) cmax=s[i];
      if (s[i]<cmin) cmin=s[i];
      i++; 
     }
    
    k=0;
    for (j=max;j>0;j--)
     {
      for (i=cmin;i<=cmax;i++) 
       {
        if (cnt[i]==j)
         {
          v=j;     
          while (v>0)
           {
            v--;
            ss[k]=i;
            k++; 
           }
         }
       }
     }
    
    ss[k]=0; 
    return(ss);
}

-----Another solution using linked list---------------------------------

char* frequencySort(char* s) {
    
    

int i;
    
int m,v,k,j,len;
    
int max=0;
    
unsigned int cmax=0;
    
unsigned int cmin=255;
    
int cnt[256];
    
unsigned char* r;   
    
    

struct node
     {
      unsigned char value;
      struct node *next;
     };

    

for (i=0;s[i]!=0;i++) {}; /* Find strlen since strlen is breaking with a very long string */
    
int lens=i;
    
char ss[lens+1];
    
struct node *vec[lens+1];  

    

for (i=0;i<256;i++) cnt[i]=0;

    

for (i=0;i<lens;i++) 
     
 {
      
  cnt[s[i]]++;
      
  v=cnt[s[i]];
      
  if (v>max) max=v;
      
  vec[i]=0;
      
  if (s[i]>cmax) cmax=s[i];
      
  if (s[i]<cmin) cmin=s[i];
     
 }
    

vec[i]=0;  

    

for (i=cmax;i>=cmin;i--)
    
 {
     
  if (cnt[i]>0)
      
   {
       
    struct node *root;   
       
    root = (struct node *) malloc( sizeof(struct node)+1 ); 
       
    root->value=i;
       
    root->next=vec[cnt[i]];
       
    vec[cnt[i]]=root;
      
   } 
   
 }

    

k=0;
    
for (j=max;j>0;j--)
     
 { 
      
  struct node *root;     
      
  root=vec[j];     
      
  while (root!=0)
       
   {
        
    v=root->value;
        
    root=root->next;
        
    for (i=j;i>0;i--) 
         
     {
          
      ss[k]=v;
          
      k++;
         
     }
       
   }
     
 }  
    
    

ss[k]=0; 
    
r=ss;
    
return(r);

}

-----And another solution using one vector linked to another and not using malloc --------------------------------------------------------------


char* frequencySort(char* s) {
    
    unsigned char* r;  
    int i;
    int k,j,len,next;
    int max=0;
    unsigned int cmax=0;
    unsigned int cmin=255;
    int cnt[256];
     
    
    for (i=0;s[i]!=0;i++) {}; /* Find strlen since strlen is breaking with a very long string */
    int lens=i;
    int ss[lens+1];
    char strR[lens+1];
    
    for (i=0;i<128;i++)   cnt[i]=0; 
    for (i=0;i<=lens;i++) ss[i]=0; 

    for (i=0;i<lens;i++) /* Count each char */
     {
      cnt[s[i]]++;
      if (cnt[s[i]]>max) max=cnt[s[i]];
      if (s[i]>cmax) cmax=s[i];
      if (s[i]<cmin) cmin=s[i];
     }

    for (i=cmax;i>=cmin;i--)    /* For all chars in the string */
    {
     if (cnt[i]>0)
      {
       next=ss[cnt[i]];       
       ss[cnt[i]]=i;          /* Point occurrences vector to char vector */
       cnt[i]=next;           /* Point char to next char */
      } 
    }

    k=0;
    for (j=max;(j>0) && (k<lens);j--)       /* Take all cases and repeat number of occurrences to build string */
     {
      next=ss[j];  
      while ((next!=0) && (k<lens))
       {
        for (i=j;(i>0) && (k<lens);i--) 
         {
          strR[k]=next;
          k++;
          
         }
        next=cnt[next];
       }
     }  
    strR[k]=0; 
    r=strR;
    return(r);
}
================================================================================================================================================

463. Island Perimeter

public class Solution {
    public int islandPerimeter(int[][] grid) {
        int i,j,p=0;
        
        for (i=0;i<grid.length;i++)
        {
            for (j=0;j<grid[i].length;j++)
            {
                if (grid[i][j]==1)
                {
                 if (i==0) 
                   p++;
                 else
                  if (grid[i-1][j]==0) p++;
                 if (j==0) 
                  p++;
                 else
                  if (grid[i][j-1]==0) p++;
                 if (i==grid.length-1) 
                   p++;
                 else
                  if (grid[i+1][j]==0) p++;
                 if (j==grid[i].length-1) 
                   p++;
                 else
                  if (grid[i][j+1]==0) p++;                 
                }
            }
        }
        return(p);
    }
    
}

================================================================================================================================================

498. Diagonal Traverse

class Solution {
    public int[] findDiagonalOrder(int[][] matrix) {

    int[] p ={0,0};                 // point p set to start 0,0
    boolean up=true;                // starting to go up
    int m=matrix.length;            // if matrix is empty returns empty
    if (m==0) 
     {   
       int[]x ={}; 
       return(x);
     }  
    int n=matrix[0].length;         // n = number of columns, m = number of lines        
        
    int[] r = new int[m*n];         // result length = m*n
        
        
    if (m==1) return (matrix[0]);   // if one line return line
    if (n==1)                       // if one column return column as line
     { 
      int i;  
      for (i=0;i<m;i++) r[i]=matrix[i][0];
      return(r);    
     }   
        
    int k=0;    
    while ((p[1]!=m-1) || (p[0]!=n-1))
    {
     r[k]=matrix[p[1]][p[0]];                  // Keep all steps
//   System.out.println(p[0]+"  "+p[1]);   
     k++;    
     if (up)                                  // Going up
      { 
       p[0]++;
       p[1]--;
       if ((p[1]<0) && (p[0]==n))              // Corner - right / up
        {
         p[1]=1;
         p[0]=n-1;  
         up=false;  
        }
       else
        {   
         if (p[1]<0)                            // Top edge
          {
           p[1]=0;
           up=false;  
          }
         if (p[0]==n)                           // Right edge        
          {
           p[0]=n-1;
           p[1]=p[1]+2;  
           up=false;  
          }
        }
      }   
     else                                       // going down
      { 
       p[0]--;
       p[1]++;
       if ((p[0]<0) && (p[1]==m))               // Corner   left / down
        {
         p[1]=m-1;
         p[0]=1;  
         up=true;  
        }
       else
        {   
         if (p[0]<0)                            // Left edge
          {
           p[0]=0;
           up=true;  
          }
         if (p[1]==m)                            // Bottom edge
          {
           p[1]=m-1;
           p[0]=p[0]+2;  
           up=true;  
          }
        }
      }   
    }
   r[k]=matrix[p[1]][p[0]];                      // Add last item (right , bottom)
   return(r);                                    // return
 }
}

================================================================================================================================================

500. Keyboard Rule

class Solution {
    public String[] findWords(String[] words) {
        String[] r = new String [words.length];
        
        String[] linhas = {"qwertyuiopQWERTYUIOP","asdfghjklASDFGHJKL","zxcvbnmZXCVBNM"};
        int i,j,k,g=0;
        
        for (i=0;i<words.length;i++)
         {
          String fl=words[i].substring(0,1);
          for (j=0;j<3;j++)
           {
            if (linhas[j].contains(fl))
             {
              k=0;  
              while (linhas[j].contains(words[i].substring(k,k+1)))
               {
                k++;
                if (k==words[i].length())
                 {
                  r[g]=words[i];
                  g++;  
                  break;  
                 }   
               }   
             }   
           }   
         } 
       
       String[] r2 = new String [g];
       for (i=0;i<g;i++) r2[i]=r[i];
       return(r2); 
        
    }
}

================================================================================================================================================

506. Relative Ranks

class Solution {
    public String[] findRelativeRanks(int[] nums) {
        
    long ns [] = new long[nums.length];
     
    int i;
        
    for (i=0;i<nums.length;i++) ns[i]=nums[i]*10000+i;       /* Keep original pos in lowest bits */
    Arrays.sort(ns);                                         /* Order */
    for (i=0;i<nums.length;i++) ns[i]=(ns[i]%10000)*10000+(nums.length-i);  /* Orig.pos->upper bits, inv.order pos->lowest bits*/
    Arrays.sort(ns);
    String s[] = new String[nums.length];    
    for (i=0;i<nums.length;i++)                              /* Create string array with each order position */
     {
      long x=(ns[i]%10000);
      if (x==1) s[i]="Gold Medal";
      if (x==2) s[i]="Silver Medal";
      if (x==3) s[i]="Bronze Medal";
      if (x>3) s[i]=""+x;
     } 
    return(s);    
  }
}

================================================================================================================================================

530. Minimum Absolute Difference in BST 


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int getMinimumDifference(TreeNode root) {
     int r=-1,l=-1;        
     if (root!=null)
      {
       if (root.left!=null)
        {
         l=findMinDiff(root.left,root.val);
         int x=getMinimumDifference(root.left);
         if ((x>=0) && (x<l)) l=x;
        }
       if (root.right!=null)
        {
         r=findMinDiff(root.right,root.val);
         int x=getMinimumDifference(root.right);
         if ((x>=0) && (x<r)) r=x;
        }
      }
     if ((r>=0) && (l>=0)) return (r < l ? r : l);
     return ( r < 0 ? l : r);
    }

int findMinDiff(TreeNode root, int n)
 {
  int dif,l,r;
  if (root==null) return (-1);
  dif=Math.abs(root.val-n);
  if (root.left!=null) 
   {
    if (Math.abs(root.left.val-n)<dif) dif=Math.abs(root.left.val-n);
    int x=findMinDiff(root.left,n);
    if ((x>=0) && (x<dif)) dif=x;
   }
  if (root.right!=null)
   {
    if (Math.abs(root.right.val-n)<dif) dif=Math.abs(root.right.val-n);
    int x=findMinDiff(root.right,n);
    if ((x>=0) && (x<dif)) dif=x;
   }
  return(dif);
 }
}

================================================================================================================================================

535. Encode and Decode TinyURL 

public class Codec {

Map<String, String> urls = new HashMap<>();  
char max=126; 
char min=33;  


    // Encodes a URL to a shortened URL.
    public String encode(String longUrl) {
        
        if (urls.containsKey(longUrl))
         return(urls.get(longUrl));
        else
         {
          Random rand = new Random();    
          String str="xxx";
          while (str.equals("xxx"))
           {
            str="http://tinyurl.com/";
            for (int i=0;i<6;i++)
             {
              str=str+(char)(min+rand.nextInt(max-min+1));     
             }
            if (urls.containsValue(str)) str="xxx";
           }
          urls.put(longUrl,str);
          System.out.println(str);
          return(str);
         }
    }

    // Decodes a shortened URL to its original URL.
    public String decode(String shortUrl) {
        if (!urls.containsValue(shortUrl))
         return("");
        else
         {
          for(Map.Entry entry: urls.entrySet())
           {
            if(shortUrl.equals(entry.getValue()))
             {
              return(""+entry.getKey());

             }
           }
         }
         return("");
    }
        

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(url));


// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(url));


}

================================================================================================================================================

539. Minimum Time Difference

public class Solution {
    public int findMinDifference(List<String> timePoints) {
        
        int i,min=12*60+1;
        int[] tminutes = new int[timePoints.size()]; 
     
        for (i=0;i<tminutes.length;i++)
         {
          int j=0;
          int hour=0;
          int minute=0;
          String time=timePoints.get(i);
          while (time.charAt(j)!=':')
           {
            hour=hour*10+time.charAt(j)-'0';
            j++;
           }
          j++;
          while (j<time.length())
           {
            minute=minute*10+time.charAt(j)-'0';
            j++;
           }
          tminutes[i]=hour*60+minute;
         }
        Arrays.sort(tminutes);
        for (i=0;i<tminutes.length-1;i++)
         {
          if (min>tminutes[i+1]-tminutes[i]) min=tminutes[i+1]-tminutes[i];    
         }
        return (min<24*60+tminutes[0]-tminutes[tminutes.length-1]) ? min : 24*60+tminutes[0]-tminutes[tminutes.length-1];
    }
}

================================================================================================================================================

541. Reverse String II 


char* reverseStr(char* s, int k) {
 int i=0;
 bool invert=true;
 
 while (i+k<strlen(s))
  {
   if (invert)
    {
     revertK(s+i,k);
     invert=false;
    }
   else
    invert=true;
   i=i+k;
  }      
 if (invert) revertK(s+i,strlen(s)-i); 
 return(s);
}

void revertK (char* s, int k)
{
 int i=0;
 char c;
 
 while (i<k-i-1)
  {
   c=s[i];
   s[i]=s[k-i-1];
   s[k-i-1]=c;
   i++;
  }
}


================================================================================================================================================


542. 01 Matrix

public class Solution {
    public int[][] updateMatrix(int[][] matrix) {
        
        int i,j,search=0;
        int up,down,left,right;
        
        boolean redo=true;
        
        while (redo)
         {
          redo=false;
          for (i=0;i<matrix.length;i++)
           {
            for (j=0;j<matrix[i].length;j++)
             {
              if (matrix[i][j]==search)
               {
                if (vup(matrix,i,j)==1)     matrix[i-1][j]=search-1;
                if (vdown(matrix,i,j)==1)   matrix[i+1][j]=search-1;
                if (vleft(matrix,i,j)==1)   matrix[i][j-1]=search-1;
                if (vright(matrix,i,j)==1)  matrix[i][j+1]=search-1;
               }
              else
               if (matrix[i][j]==1) redo=true;
             }
           }
          search--;
         }
        for (i=0;i<matrix.length;i++)
         for (j=0;j<matrix[i].length;j++)
          matrix[i][j]=-matrix[i][j];
        return(matrix);  
    }
    
int vup (int [][] m, int i, int j)
{
 if (i==0) return (11000);
 return (m[i-1][j]);
}


int vdown (int [][] m, int i, int j)
{
 if (i==m.length-1) return (11000);
 return (m[i+1][j]);
}

int vleft (int [][] m, int i, int j)
{
 if (j==0) return (11000);
 return (m[i][j-1]);
}

int vright (int [][] m, int i, int j)
{
 if (j==m[i].length-1) return (11000);
 return (m[i][j+1]);
}

}

================================================================================================================================================

575. Distribute Candies

class Solution {
    public int distributeCandies(int[] candies) {
        
    int total=0;
    int types=0;
    int i;
    int[] control=new int[200001];   
    for (i=0;i<candies.length;i++)
     {
      if (++control[candies[i]+100000]==1) types++;
      total++;  
     }   
     return (types<=total/2 ? types : total/2);  
        
    }
}

------------------------------------------------------------------------

int distributeCandies(int* candies, int candiesSize) {
    int total=0;
    int types=0;
    int i;
    int control[200001]={0};   
    
    for (i=0;i<candiesSize;i++)
     {
      if (++control[candies[i]+100000]==1) types++;  
      total++;  
     }   
     return (types<=total/2 ? types : total/2);  
    
}

================================================================================================================================================

594. Longest Harmonious Subsequence

public class Solution {
    public int findLHS(int[] nums) {
    
    Map<Integer, Integer> control = new HashMap<>();
    
    List<Integer> ns = new ArrayList<Integer>();    
    
    int i,x,max=0,tmax;
        
    for (i=0;i<nums.length;i++)               /* Add all values to list ns and also to hash table control with number of occurrences */
     {
      x=0;  
      if (control.containsKey(nums[i]))
       {
        x=control.get(nums[i]);
       }
      else
       {
        ns.add(nums[i]);   
       }
      control.put(nums[i],x+1); 
     }
        
    for (i=0;i<ns.size();i++)                 /* For every value of list ns, try to get value++ and value--and see if occurrences > max */ 
     {
      x=ns.get(i);  
      if (control.containsKey(x+1))
       {
        tmax=control.get(x)+control.get(x+1);
        if (tmax>max) max=tmax;  
       }      if (control.containsKey(x+1))
      if (control.containsKey(x-1))
       {
        tmax=control.get(x)+control.get(x-1);
        if (tmax>max) max=tmax;  
       }   
     }   
   return(max);     
  }
}

================================================================================================================================================

605. Can Place Flowers

public class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int i=0;
        int last=0;
        int next;
        
        while ((i<flowerbed.length) && (n>0))
         {
          if ((i+1)<flowerbed.length)
           next=flowerbed[i+1];
          else
           next=0;
          if ((last+next+flowerbed[i])==0) 
           {
            n--;
            last=1;
           }
          else
           last=flowerbed[i];
          i++;
         }
        return (n==0); 
    }
}


================================================================================================================================================
606. Construct String from Binary Tree

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public String tree2str(TreeNode t) {
        if (t==null) return("");
        if ((t.left!=null) && (t.right!=null)) return (""+t.val+"("+tree2str(t.left)+")("+tree2str(t.right)+")");  
        if ((t.left!=null) && (t.right==null)) return (""+t.val+"("+tree2str(t.left)+")");
        if ((t.left==null) && (t.right!=null)) return (""+t.val+"()("+tree2str(t.right)+")");
        return (""+t.val);
    }
}

================================================================================================================================================

621. Task Scheduler

int leastInterval(char* tasks, int tasksSize, int n) {
    
    int i,j,k;
    int interval=0;

    int nchars='Z'-'A'+1;
    int x[nchars];
    int control[tasksSize+1];

    if (n==0) return(tasksSize);
    
    n=n+1;    
    
    for (i=0;i<nchars;i++) x[i]=0;   
    for (i=0;i<tasksSize;i++) x[tasks[i]-'A']++;  /* Count occurrence of each char */
    for (i=1;i<=tasksSize;i++) control[i]=0;     
    for (i='A';i<='Z';i++) if (x[i-'A']>0) control[x[i-'A']]++;  /* Count number of chars per occurrence */

    i=tasksSize;
    while (i>1)      /* Shift down n+1 chars every time */
     {
      if (control[i]>0)
        {
         j=0;
         k=i+1;
         while (j<n)
          {
           k--;
           if (k==0) break;
           j=j+control[k];
          }
         if (k==0)
          {
           k=1;   
          }
         else
          {
           if (j>n)   /* Adjust if more than number of chars */
            {
             control[k-1]=control[k-1]+n-j+control[k];
             control[k]=control[k]-n+j-control[k];
             k++;
            }
          }
         while (k<=i)   /*Shift*/
          {
           control[k-1]=control[k-1]+control[k];
           control[k]=0;
           k++;
          }
         interval=interval+n; /* Every time increase interval in N */
        }
        if (control[i]==0) i--; /* If highest counter is 0 go to next one, if not reprocess */
      }
    interval=interval+control[i];
    return(interval);
    
}

================================================================================================================================================

624. Maximum Distance in Arrays

int maxDistance(int** arrays, int arraysRowSize, int *arraysColSizes) {
    

    int i,j;
    
    int vmin=0, vmax=0, vmin2=0, vmax2=0, pmin, pmax, p2;
    
    pmin=-1;
    pmax=-1;
    
    p2=-1;
    
    for (i=0;i<arraysRowSize;i++)
     {
      if ((pmin<0) & (pmax<0))     /* Find min and max of all vectors */
       {
        pmin=i;
        pmax=i;
        vmin=arrays[i][0];
        vmax=arrays[i][arraysColSizes[i]-1];
        vmin2=vmin;
        vmax2=vmax;
       }
      else
       {
        if (p2<0)                /* Also find 2nd min and 2nd max */
         {
          p2=0;
          vmin2=arrays[i][0];
          vmax2=arrays[i][arraysColSizes[i]-1];
         }
        if (vmin>arrays[i][0])
         {
          vmin2=vmin;         
          vmin=arrays[i][0];
          pmin=i;
         }
        else
         {
          if (vmin2>arrays[i][0]) vmin2=arrays[i][0];
         }
        if (vmax<arrays[i][arraysColSizes[i]-1])
         {
          vmax2=vmax;     
          vmax=arrays[i][arraysColSizes[i]-1];
          pmax=i;
         }
        else
         {
          if (vmax2<arrays[i][arraysColSizes[i]-1]) vmax2=arrays[i][arraysColSizes[i]-1];
         }
       }
     }  
    
    if (pmin!=pmax) return (vmax-vmin);  /* If max and min are from different vectors, return max-min */
    
    return ((vmax-vmin2) > (vmax2-vmin)) ?  (vmax-vmin2) : (vmax2-vmin);  /* If not return the largest between max-2nd min & 2nd max-min */
      
    
}

================================================================================================================================================

625. Minimum Factorization

public class Solution {
    public int smallestFactorization(int a) {
        
    int r=0;
    int rf=0;
    int j=9;
    
    if (a==1) return (a);
    
    while (j>1)
     {
      while (a%j==0) 
       {
        a=a/j;
        if (r*10/10!=r) return(0);
        r=r*10+j;
       }
      j--;
      if (a==1) break;
     }
    
    while (r!=0)
     {
      rf=rf*10+r%10;
      r=r/10;
     }
    
    return (a==1) ? (int)rf : 0;    
    }
}

================================================================================================================================================

628. Maximum Product of Three Numbers

public class Solution {
    public int maximumProduct(int[] nums) {
        
        int[] max = {-1001,-1001,-1001};
        int[] min = {1001,1001};
        
        int i;
        
        for (i=0;i<nums.length;i++)
         {
          if (nums[i] > max[2])
           {
            max[2]=nums[i];
            if (max[2]>max[1])
             {
              max[2]=max[1];
              max[1]=nums[i];
             }   
            if (max[1]>max[0])
             {
              max[1]=max[0];
              max[0]=nums[i];
             }   
           }
          if (nums[i] < min[1])
          {
           min[1]=nums[i];
           if (min[1]<min[0])
            {
             min[1]=min[0];
             min[0]=nums[i];  
            }   
          }   
       }   
      
     if (nums.length==3)  return (max[0]*max[1]*max[2]); 
     return (max[0]*max[1]*max[2]>max[0]*min[0]*min[1]) ?  (max[0]*max[1]*max[2]) : (max[0]*min[0]*min[1]);  
            
    }
}

================================================================================================================================================

680. Valid Palindrome II

class Solution {
    public boolean validPalindrome(String s) {

     int i=0,j=s.length()-1;  
     
     while (i<j)
     {
      if (s.charAt(i)!=s.charAt(j)) 
       {
        return ((ispalindrome(s.substring(i+1,j+1))) || (ispalindrome(s.substring(i,j)))); 
       }   
      i++;
      j--;   
     } 
     return(true);   
        
    }
    
    boolean ispalindrome (String s)
    {
     int i=0,j=s.length()-1;
        
     while (i<j)
     {
      if (s.charAt(i)!=s.charAt(j)) return(false);
      i++;
      j--;   
     } 
     return (true);   
    }  
}
        
================================================================================================================================================

Function to generate all possible multiples from a int vector with prime numbers:

O=N*(2^N)

#include <stdio.h>

void geramult (int *nums, int s)
 {
  long i,r,map=0,flag;


  for (map=1;map<(1<<s);map++)
   {
    flag=1;
    r=1;
    i=0;
    while (flag<(1<<s))
     {
      if (flag&map) r=r*nums[i];
      i++;
      flag=flag<<1;
     }
    printf("%lu ",r);
   }
   printf("\n");
   return;
  }


int main()
 {
  int param[10]={2,3,5,7,11};
  geramult(param,5);
 }

--------------------------------------------------------------------------

In Java reusing previous multiplication results:

O = 2^(N-1)

import java.util.ArrayList;
import java.util.List;

import static java.awt.SystemColor.control;

public class Main {

    public static void main(String[] args) {

    int[] teste={2,3,5,7,11,13,17};
    geramult(teste);

    }


    static void geramult (int [] nums)
    {
     List<Integer> controle  = new ArrayList<>();

     Integer i,j,s;

     for (i=0;i<nums.length;i++)
      {
       controle.add(nums[i]);
       System.out.print(nums[i]+" ");
       s=controle.size();
       j=0;
       while (j+1<s)
        {
         controle.add(nums[i]*controle.get(j));
         System.out.print(nums[i]*controle.get(j)+" ");
         j++;
        }
      }
     System.out.println("");
     return;

    }

}


--------------------------------------------------------------------------

Same using same list

O = 2^(N-1)

import java.util.ArrayList;
import java.util.List;

import static java.awt.SystemColor.control;

public class Main {

    List<Integer> tempx=new ArrayList<Integer>();
        
    tempx.add(2);
    tempx.add(3);
    tempx.add(5);
    tempx.add(7);
    tempx.add(11);
    tempx.add(13);
    tempx.add(17);
    tempx.add(19);

        
    geramult(tempx);

    }



void geramult (List<Integer> lista)

{
int s=lista.size();
int limit=s;
int i,n=0;

while (n<s)
  {
   System.out.print(lista.get(n)+" "); 
   int s2=lista.size(); 
   for (i=0; i<n; i++)
    { 
     int x=lista.get(i)*lista.get(n);
     System.out.print(x+" ");
     lista.add(x);
    }
   for (i=s; i<s2; i++)
    { 
     int x=lista.get(i)*lista.get(n);
     System.out.print(x+" ");
     lista.add(x);
    }
   n++;
  }    
 return;
}


