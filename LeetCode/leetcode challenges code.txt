================================================================================================================================================

1. Two Sum

public class Solution {
    public int[] twoSum(int[] nums, int target) {
 

    int i,j;
 
    int r[]=new int[2];
    
    for (i=0;i<nums.length-1;i++)
    {
        for (j=i+1;j<nums.length;j++)
        {
         if (nums[i]+nums[j]==target)
         {
          r[0]=i;
          r[1]=j;
          return(r);
         }
       }
    }

   return (null); 
}
}

================================================================================================================================================

5. Longest Palindromic Substring

public class Solution {
    public String longestPalindrome(String s) {

 
   int i,j,k,kk,jj,v;
   int imax=0;
   int jmax=1;
   
   if (s.length()==0) return(s);
   
 
  
   for (i=0;i<s.length();i++) /* Looking each char in the string */
    {
     k=i;
     j=jmax;
     for (v=0;v<=1;v++) /* Twice, for even and odd size palindromes*/
      {
       j++;
       if ((k-j/2+j<=s.length()) && (k-j/2>=0)) /* Checking if verification is not outside of the string */
        {
         if (ispal (s.substring(k-j/2,k-j/2+j)))  /* If is palindrome ... */
          { 
           kk=k-j/2;
           jj=j;
           while (s.charAt(kk)==s.charAt(kk+jj-1)) /* Try to see if adding one more char on each side is still palindrome */
            {
             kk--;
             jj++;
             jj++;
             if ((kk<0) || (kk+jj>s.length())) break; /* If not inside string, stop */
            }
           kk++;  /* Discard last two chars that did not work */
           jj--;
           jj--;
           imax=kk;  /* New max values */
           jmax=jj;
           j=jmax;
          }
        }
      } 
    }
   return (s.substring(imax,imax+jmax)); /* Return the longest string */
}
        


  boolean ispal (String s)  /* Check if string is palindrome */
    {
     int i;    
     for (i=0;i<s.length()-i-1;i++)
      {
       if (s.charAt(i)!=s.charAt(s.length()-i-1)) return (false);      
      }
     return (true); 
    }  
    

    
}

================================================================================================================================================

7. Reverse Integer 

public class Solution {
    public int reverse(int x) {
        
 
    int r[] = new int[1000];
    int i,j;
    int neg=0;
    
    if (x<0) 
     {
         neg=1;
         x=-x;
     }
    j=0;
    while (x!=0)
    {
        r[j]=x%10;
        x=x/10;
        j++;
    }
    for (i=0;i<j;i++)
    {
        if (x*10/10!=x) return (0);     
        x=x*10+r[i];
    }
    if (neg==1) 
      return(-x);
    else
      return (x);
  }
}

================================================================================================================================================

8. String to Integer (atoi)  

int myAtoi(char* str) {
    
    int i,st=0;
    int value=0;

    int signal=1;
    i=st;
    while (str[i]==' ')
     {
         i++;
     }   
    st=i;
    if (str[st]=='-')
     {
         signal=-signal;
         st++;
     }
    else if (str[st]=='+')
     {
         st++;
     }

    for (i=st;i<strlen(str);i++)
    {
     if ((str[i]>='0') && (str[i]<='9'))
      {
       if (value*10/10!=value)
        {
           if (signal>0) return (0x7FFFFFFF);
           if (signal<0) return (0x80000000);
        }
       value=value*10-'0'+str[i];
   /*    printf(" %d\n",value);  */
       if (value < 0) 
        {
            if (signal>0) return (0x7FFFFFFF);
            if (signal<0) return (0x80000000);
        }
      }
     else
      break;
    }
    return(signal*value);
}
================================================================================================================================================

20. Valid Parentheses 

public class Solution {
    public boolean isValid(String s) {
        
    String parse="";
    
    String open="[{("";
    int i,size;
    
    size=s.length;
    
    for (i=0;i<size;i++)
    {
     if (open.indexOf(s.substring(i,i))
      {
          parse=parse+s.substring(i,i);
      }
      else
      {
          if is(s.substring(i,i))
      }
    }
 
    }
}

----------------------------------------------------------------

bool isValid(char* s) {

    char parse[1000];
    
    
    int i,j,size;
    bool status=false; 
    j=0;
    size=strlen(s);
 
    for (i=0;i<size;i++)
    {
     if ((s[i]=='(') || (s[i]=='[') || (s[i]=='{'))
      {
          parse[j]=s[i];
          j++;
      }
      else
      {  
          j--;
          if (parse[j]=='(')
           {
               if (s[i]!=')') return(status);
           }
          else
           {
            if (parse[j]=='[')
             {
               if (s[i]!=']') return(status);
             }
            else /* parse[j]=='{' */
             {
                if (s[i]!='}') return(status);
             }
           }
           
       }
      
     }
     if (j==0) status=true;
     return(status);
}

================================================================================================================================================

27. Remove Element 

int removeElement(int* nums, int numsSize, int val) {
    
    int i,j;
    
    i=0;
    j=0;
    
    while (j<numsSize)
    {
        if (nums[j]==val)
         {
          j++;
         }
        else
         {
          nums[i]=nums[j];        
          i++;
          j++;
         }
         
         
    }
    return (i);
}

================================================================================================================================================

28. Implement strStr()  

int strStr(char* haystack, char* needle) {
    
    int i;
    
    
    if(strlen(haystack)<strlen(needle)) return(-1);
    
    
    for (i=0;i<=(strlen(haystack)-strlen(needle));i++)
    {
        
        if (strncmp(haystack+i,needle,strlen(needle))==0) return (i);
    }
    
    return(-1);
}

================================================================================================================================================

30. Substring with Concatenation of All Words 

public  class Solution {
        public  List<Integer> findSubstring(String s, String[] words) {

         int i,j,k, pr;

         String toFind, isgood="", isbad="";
         
         List<Integer> result=new ArrayList<Integer>();
         
         boolean found=false;
         
         int nwords=words.length;
         
         int swords=words[0].length();
         
         
         boolean ispart[] = new boolean[nwords];
         
         
         
         pr=0;
         
         if (nwords*swords>s.length()) return (result);   
         

         for (j=0;j<=(s.length()-nwords*swords);j++)
            {
             if (isgood.contains(":::"+s.substring(j,j+nwords*swords)+"==="))
             {
              result.add(pr,j);
              pr++; 
             }
             else
             {
              if (!isbad.contains(":::"+s.substring(j,j+nwords*swords)+"==="))
              {
               for (i=0;i<nwords;i++) ispart[i]=false; 
               for (k=0;k<nwords;k++)
                {
                 toFind=s.substring(j+k*swords,j+swords*(k+1));
                 found=false;
                 for (i=0;i<nwords;i++) 
                  {
                   if ((!ispart[i]) && (toFind.equals(words[i])))
                    {
                     ispart[i]=true;
                     found=true;
                     break;
                    }
                  }
                 if (!found) 
                  {
                   isbad=isbad+":::"+s.substring(j,j+nwords*swords)+"===";
                   break;
                  }
               }
                if (found)
                 {
                  isgood=isgood+":::"+s.substring(j,j+nwords*swords)+"===";
                  result.add(pr,j);
                  pr++;
                 }
               }
              }
            }

         return(result);
     }
 }


================================================================================================================================================

33. Search in Rotated Sorted Array  
 
public class Solution {
    public int search(int[] nums, int target) {

        int i=0;
        
        int part=0;
        
        while (i<nums.length)
        {
         if ((part==2) && (target < nums[i])) return(-1);    
         if ((part==1) && (nums[i]<nums[i-1])) part=2;  
         if((nums[i]>target) && (part==0)) 
          part=1;
         else
          if((nums[i]<target) && (part==0)) 
           part=2;
          else 
           if (nums[i]==target) return(i);
         i++;
        }
        
        return(-1);
    }
}
================================================================================================================================================

43. Multiply Strings 

public class Solution {
    public String multiply(String num1, String num2) {
        
        String r="0",r2;
        
        int i,j,k,x;
        
        for (i=0;i<num1.length();i++)
         {
          for (j=0;j<num2.length();j++)
           {
            x=(num1.charAt(num1.length()-i-1)-'0')*(num2.charAt(num2.length()-j-1)-'0');
            String st="";
            if (x/10>0) st=st+(char)('0'+x/10);
            st=st+(char)('0'+x%10);
            r2=r.substring(r.length()-i-j);
            r=adds(r.substring(0,r.length()-i-j),st);
            r=r+r2;
           }          
         }
        while ((r.charAt(0)=='0') && (r.length()>1))
         {
          r=r.substring(1);
         }
        return(r);
    }
    
    public String adds(String num1, String num2)
    {
        int i,x,togo=0;
        String res="";
        String s,l;
        if (num2.length() > num1.length())
         {
          s=num1;
          l=num2;
         }
        else
         {
          s=num2;
          l=num1;
         }
        for (i=0;i<l.length();i++)
        {
         if (i<s.length())
          {
           x=s.charAt(s.length()-i-1)-'0'+l.charAt(l.length()-i-1)-'0'+togo;
           togo=x/10;
           res=(char)('0'+x%10)+res;
          }
         else
          {
           if (togo>0)
            {
             x=l.charAt(l.length()-i-1)-'0'+togo;
             togo=x/10;
             res=(char)('0'+x%10)+res;
            }
           else
            {
             res=l.substring(0,l.length()-i)+res;
             break;  
            }
            
          }
        }
        if (togo==1) res="1"+res;
        return(res);
    }
    
}

================================================================================================================================================

48. Rotate Image 

public  class Solution {
    public  void rotate(int[][] matrix) {



        int i=0;
        int j=0;
        int size;

        size=matrix.length;

        int[][] m=new int[size][size];


        for (i=0;i<size;i++)
        {
            for (j=0;j<size;j++)
            {
                m[j][size-i-1]=matrix[i][j];
            }
        }

        for (i=0;i<size;i++)
        {
            for (j=0;j<size;j++)
            {
                matrix[i][j]=m[i][j];


            }
        }

    }
}

-------------------------------------------------------------------------------

void rotate(int** matrix, int matrixRowSize, int matrixColSize) {
    
    int i=0;
    int j=0;
    
    int m[matrixRowSize][matrixColSize];
    
    for (i=0;i<matrixRowSize;i++)
    {
        for (j=0;j<matrixColSize;j++)
        {
            m[j][matrixColSize-i-1]=matrix[i][j];
        }
    }

    for (i=0;i<matrixRowSize;i++)
    {
        for (j=0;j<matrixColSize;j++)
        {
            matrix[i][j]=m[i][j];
        }
    }
}    

================================================================================================================================================

118. Pascal's Triangle 

public class Solution {
    public List<List<Integer>> generate(int numRows) {
        
        int i,j;
        
        List<List<Integer>> r = new ArrayList<>();
  
        int prev_line[] = new int[numRows];
        int line[] = new int [numRows];
        
        for (i=1;i<=numRows;i++)
        {
         List<Integer> l = new ArrayList<>();
         line[0]=1;
         for (j=1;j<i-1;j++)
          {
           line[j]=prev_line[j-1]+prev_line[j];   
          }
         line[i-1]=1;
         for (j=0;j<i;j++)
          {
           prev_line[j]=line[j];
           l.add(line[j]);
          }
          r.add(l);
          /* l.clear();  */
          l=null; /* To release the memory used for l */
        }
        return(r);
    }
}

================================================================================================================================================

122. Best Time to Buy and Sell Stock II 

public class Solution {
    public int maxProfit(int[] prices) {
        
        int i,dif=0,profit=0;
        
        int min=-1;
        
        for (i=0;i<prices.length;i++)
        {
         if (min<0) 
          min=prices[i];
         else
          { 
           if (prices[i]>min+dif) dif=prices[i]-min; 
           if ((prices[i]<prices[i-1]) && (dif!=0))
            {
              profit=profit+dif;
              dif=0;
              min=prices[i];
            }
           if (prices[i]<min) min=prices[i];
          }
 
        }
        profit=profit+dif;
        return(profit);
    }
}

================================================================================================================================================

143. Reorder List 

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void reorderList(ListNode head) {

        ListNode p,p1=head,p2=head;
        
        /*  Find Center */
        
        while (p2!=null)
         {
          p2=p2.next;
          if (p2!=null) 
           { 
               p2=p2.next;
               p1=p1.next;
           }
         }
        if (p1!=null)
         {
             p2=p1.next;
             p1.next=null;
             p1=p2;
         }

/* print_cadeia(head);
print_cadeia(p1);*/

        /* Invert (half) list */

        ListNode p_prev=null;
        while (p1!=null)
        {
         ListNode p_next=p1.next;
         p1.next=p_prev;
         p_prev=p1;
         p1=p_next;
        }
        p1=p_prev;
        
/* print_cadeia(head);
print_cadeia(p1);*/

        /* Merge */
        p2=head;
        while ((p1!=null) && (p2!=null))
        {
            ListNode p2_next=p2.next;
            p2.next=p1;
            ListNode p1_next=p1.next;
            p1.next=p2_next;
            p2=p2_next;
            p1=p1_next;
        }

/* print_cadeia(head); */

}
    
void print_cadeia(ListNode p)
{
while (p.next!=null)
{
    System.out.print(p.val+" ");
    p=p.next;
}
System.out.println(p.val);
}
    
    
}

================================================================================================================================================

150. Evaluate Reverse Polish Notation 

public class Solution {
    public int evalRPN(String[] tokens) {
        Deque <Integer> p = new LinkedList<>();
        
        int i,temp;
        
        boolean isNumber;
        
        for (i=0;i<tokens.length;i++)
        {
         isNumber=true;
         if  (tokens[i].equals("+"))
         {
          temp=p.removeFirst();
          temp=p.removeFirst()+temp;
          p.addFirst(temp);
          isNumber=false;
         }
         if  (tokens[i].equals("-"))
         {
          temp=p.removeFirst();
          temp=p.removeFirst()-temp;
          p.addFirst(temp);
          isNumber=false;
         }
         if  (tokens[i].equals("*"))
         {
          temp=p.removeFirst();
          temp=p.removeFirst()*temp;
          p.addFirst(temp);
          isNumber=false;
         }
         if  (tokens[i].equals("/"))
         {
          temp=p.removeFirst();
          temp=p.removeFirst()/temp;
          p.addFirst(temp);
          isNumber=false;
         }
         if (isNumber)
          {
           p.addFirst(Integer.parseInt(tokens[i]));  
          }
        }
        return (p.peekFirst());
    }
}

================================================================================================================================================

155. Min Stack  

/* public class MinStack {
    long min;
    Stack<Long> stack;

    public MinStack(){
        stack=new Stack<>();
    }
*/
public class MinStack {

    Deque <Integer> stack;
    Deque <Integer> minstack;
    
    /** initialize your data structure here. */
    public MinStack() {
        /* Create two stacks, 1 for min */ 
        stack = new LinkedList<>(); 
        minstack = new LinkedList<>(); 
        
    }
    
    public void push(int x) {
        /* If x < min push x to minstack, if not push min */
        
        int min=x;
        stack.addFirst(x);
        if (!minstack.isEmpty()) min = getMin();
        if (x < min)  min =x;
        minstack.addFirst(min);
        
    }
    
    public void pop() {
        /* Get and remove last value from stack and min stack */
        minstack.removeFirst();
        stack.removeFirst();
    }
    
    public int top() {
        /* Get last value from stack */
        return (stack.peekFirst());
    }
    
    public int getMin() {
        /* Get last value from min stack */
        
        return (minstack.peekFirst());
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */

================================================================================================================================================

207. Course Schedule

public class Solution {
    
    Map<Integer, List<Integer>> cursos = new HashMap<>();
    
    public boolean canFinish(int numCourses, int[][] prerequisites) {

        int i,j,k,x;
        
        for (i=0;i<prerequisites.length;i++)        /* Creating hash table with courses with pre requisites */
         {
          if (!cursos.containsKey(prerequisites[i][0]))
            {
             List<Integer> temp = new ArrayList<Integer>();
             temp.add(prerequisites[i][1]);
             cursos.put(prerequisites[i][0],temp);
            }
           else
            {
             List<Integer> temp =cursos.get(prerequisites[i][0]);
             temp.add(prerequisites[i][1]);
             cursos.put(prerequisites[i][0],temp);
            }
         }
        int cstatus []=new int[numCourses];       /* Verify if each course pass in pre req test */
        for (i=0;i<numCourses;i++) cstatus[i]=0;
        for (i=0;i<numCourses;i++)
         {
          if (cstatus[i]==0)
           {
            if (cursos.containsKey(i))
             {
              if (!passC(i,cstatus)) return(false);     
             }
           }
         }
        return(true); 
    }

    Boolean passC(int n, int[] status)    
     {
      if (status[n]==1) return(false);
      status[n]=1;

      if (cursos.containsKey(n))   /* Not in has table, no pre, ok */
       {
        int i;
        List<Integer> temp = new ArrayList<Integer>();
        temp=cursos.get(n);
        for (i=0;i<temp.size();i++)  /* Verify pre of pre */
         {
          if (!passC(temp.get(i),status)) return(false);  /* If any not ok, return not ok (false) */
         }  
       }
      status[n]=2;   /* if all good, ok, true */
      return(true);
     }
    
}

================================================================================================================================================

217. Contains Duplicate  

public class Solution {
    public boolean containsDuplicate(int[] nums) {
        
       Map<Integer, Integer> ns = new HashMap<>();
       
       int i;
       
       for (i=0; i< nums.length; i++)
        {
         if (ns.containsKey(nums[i]))
          return (true);
         else
          ns.put(nums[i],i);
        }
        return(false);
    }
}

================================================================================================================================================

221. Maximal Square

public class Solution {
    public int maximalSquare(char[][] matrix) {
        
    int i,ii,j,jj,cnt,max=0;
    boolean isbox,loopend;
    
    for (i=0;i<matrix.length;i++)       /* For every line */
     {
      cnt=0;     
      for (j=0;j<matrix[i].length;j++)   /* and every row */
       {
        if (matrix[i][j]=='0')           /* When 0, reset word count */  
         cnt=0;
        else 
         {
          cnt++; 
          if ((cnt>max) && (cnt<=i+1))    /* When N '1s' are found check if there is a box above */
           {
            isbox=true;
            ii=0;
            jj=0;
            loopend=false;
            while ((isbox) && (!loopend))
             {
              if (matrix[i-ii][j-jj]=='0') 
               isbox=false;
              jj++;
              if (jj==cnt)
               {
                jj=0;   
                ii++;
                if (ii==cnt) loopend=true;
               }
             }
            if (isbox)                     /* If  box update Max */
             {
              max=cnt;
             }
            else                           /* If not reduce counter and continues */
             cnt--;
           }
         }
       }
     }
    return(max*max); 
   }
}

================================================================================================================================================

231. Power of Two 

public class Solution {
    public boolean isPowerOfTwo(int n) {
        int x,c=0;
        
        for (x=1;(x>0)&&(n>0);x=x<<1)
        {
         if ((n&x)!=0) c++;
         if (c==2) return (false);
        }
        return (c==1) ? true : false;  
        
/* Solution using hashmap */        
        
/* Map<Integer,Integer> power2 = new HashMap<>();  
int x=1;
while ( (x>0) && (!power2.containsKey(n)) )
 {
  power2.put(x,x);
  x=x<<1;
 }
return(power2.containsKey(n)); */
        
    }
}

================================================================================================================================================

283. Move Zeroes 

void moveZeroes(int* nums, int numsSize) {
    
    int i,j;
    
    i=0;
    j=0;
    
    while (j<numsSize)
    {
        if (nums[j]==0)
         {
          j++;
         }
        else
         {
          if (i!=j) nums[i]=nums[j];        
          i++;
          j++;
         }
    }
    for (;i<numsSize;i++) nums[i]=0;
    return;
}


================================================================================================================================================

292. Nim Game

public class Solution {
    public boolean canWinNim(int n) {
        if (n>0)
         {
          if (n%4!=0) return (true);
         }
        return (false);
    }
}
==============================================================================================================================================-=

322. Coin Change

public class Solution {
    public int coinChange(int[] coins, int amount) {
        int n=0,v=0,tmp,i,j;
        for (i=0;i<coins.length-1;i++)
         {
          for (j=0;j<coins.length-1-i;j++)
           {
            if (coins[j+1]>coins[j])
             {
              tmp=coins[j];
              coins[j]=coins[j+1];
              coins[j+1]=tmp;
             }
           }
         } 
    return (calcChange(coins, amount, 0));   
    }
    
int calcChange(int coins[], int amount, int start)
{
 int i,r=-1,min=-1;    
 if (amount==0) return (0);
 if (amount<coins[coins.length-1]) return (-1);
 for (i=start;i<=coins.length-1;i++)
  {
   if (amount==coins[i]) return(1);  
  }
 for (i=start;i<=coins.length-1;i++)
  {
   if (amount>coins[i])
    {
     if (((min==-1) || (min>((amount-coins[i])/coins[i])))) r=calcChange(coins, amount-coins[i],i);
     if ((r!=-1) && ((min==-1) || (min>r+1))) min = r+1;
    }
  }
  return(min);    
 }
}
================================================================================================================================================

336. Palindrome Pairs

public class Solution {


    public List<List<Integer>> palindromePairs(String[] words) {
        Map<String, List<Integer>> complements = new HashMap<>();
        
        int i,j,k;
        int dif_start;
        
        List<List<Integer>> r = new ArrayList<List<Integer>>();
        
        for (i=0; i<words.length;i++)            /* Add all words to a hash table */
        {
            if (!complements.containsKey(words[i])) /* If word is not repeated it's added as a new entry */
             {
              List<Integer> temp = new ArrayList<Integer>();
              temp.add(i);
              complements.put(words[i],temp);
             }
            else                                 /* If word is repeated it's added as a same entry adding sequence number to list */     
             {
              List<Integer> temp = new ArrayList<Integer>();
              temp = complements.get(words[i]); 
              temp.add(i);
              complements.put(words[i],temp);
             }
        }
        
        for (i=0; i<words.length;i++)
        {
         if ((isPalindrome(words[i])) && complements.containsKey(""))  
          {
            List<Integer> temp = new ArrayList<Integer>();
            temp = complements.get("");
            for (k=0; k<temp.size(); k++)
             {
                 if (i!=temp.get(k))
                  {
                   List<Integer> rtemp = new ArrayList<Integer>();
                   rtemp.add(i);
                   rtemp.add(temp.get(k));
                   r.add(rtemp);
                   List<Integer> rtemp2 = new ArrayList<Integer>();
                   rtemp2.add(temp.get(k));
                   rtemp2.add(i);
                   r.add(rtemp2);
                  }
             }
          }


         if (complements.containsKey(reverse(words[i]))) /* add i with found key to answer if not i */ 
          {
            List<Integer> temp = new ArrayList<Integer>();
            temp = complements.get(reverse(words[i]));
            for (k=0; k<temp.size(); k++)
             {
                 if (i!=temp.get(k))
                  {
                   List<Integer> rtemp = new ArrayList<Integer>();
                   rtemp.add(i);
                   rtemp.add(temp.get(k));
                   r.add(rtemp);
                  }
             }
          }
         
         for (j=1;j<words[i].length();j=j+1)    
          {
           if(isPalindrome(words[i].substring(0,words[i].length()-j)))  /* Trying to find palindromes to last letters */
            {
             if (complements.containsKey(reverse(words[i].substring(words[i].length()-j)))) /* add i with found key to answer if not i */
             {
              List<Integer> temp = new ArrayList<Integer>();
              temp = complements.get(reverse(words[i].substring(words[i].length()-j)));
              for (k=0; k<temp.size(); k++)
               {
                if (i!=temp.get(k))
                 {
                  List<Integer> rtemp = new ArrayList<Integer>();
                  rtemp.add(temp.get(k));
                  rtemp.add(i);
                  r.add(rtemp);
                 }
               }
             }
           }           
          if(isPalindrome(words[i].substring(j)))    /* Trying to find palindromes to first letters */
            {
             if (complements.containsKey(reverse(words[i].substring(0,j)))) /* add i with found key to answer if not i */ 
              {
               List<Integer> temp = new ArrayList<Integer>();
               temp = complements.get(reverse(words[i].substring(0,j)));
               for (k=0; k<temp.size(); k++)
                {
                 if (i!=temp.get(k))
                  {
                   List<Integer> rtemp = new ArrayList<Integer>();
                   rtemp.add(i);
                   rtemp.add(temp.get(k));
                   r.add(rtemp);
                  }
                }
              }
            }

         }
         
    }
    return(r);
}
    
 String reverse (String s)
  {
   int i;
   String r="";
   for (i=0;i<s.length();i++)
    {
     r=s.charAt(i)+r;         
    }
   return(r); 
  }
    
boolean isPalindrome (String s)
  {
   int i;
   
   for (i=0;i<s.length()-i;i++)
    {
     if(s.charAt(i)!=s.charAt(s.length()-i-1)) return(false);         
    }
   return(true); 
  }
    
}

================================================================================================================================================

344. Reverse String

public class Solution {
    public String reverseString(String s) {

    int MAX = 1000;
    
    if (s.length() > MAX)   /* For long strings, break in two */
     return (reverseString(s.substring(s.length()/2))+reverseString(s.substring(0,s.length()/2)));
    else                    /* For normal string, revert */  
     return (s.length()<=1 ? s : s.charAt(s.length()-1)+reverseString(s.substring(1,s.length()-1))+s.charAt(0));
 }
}

================================================================================================================================================

367. Valid Perfect Square 

public class Solution {
    public boolean isPerfectSquare(int num) {

        if (num<2) return(true);
        
        int min = 0;
        int max = num;
        int t;
        
        while (max-min>1)
         {
          t=(min+max)/2;
          if ((num/t==t) && (num%t==0)) return(true);
          if (t>num/t) 
           max=t;
          else
           min=t;
         }
        return(false);
    }
}

================================================================================================================================================

374. Guess Number Higher or Lower   

/* The guess API is defined in the parent class GuessGame.
   @param num, your guess
   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
      int guess(int num); */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        
        int min=1, max=n, x=0, status=2;
        
        while (status!=0)
         {
          x=(max-min)/2+min;
          status=guess(x);
          if (status==1) 
            min=x+1;
           else
            max=x-1;
          } 
        return(x);
    }
}

================================================================================================================================================

389. Find the Difference  


public class Solution {
    public char findTheDifference(String s, String t) {
        
        int i;
        String temp;
        
        i=0;
        temp=t.substring(i,i+1);
        
        while (s.contains(temp))
        {
         s=s.substring(0,s.indexOf(temp))+s.substring(s.indexOf(temp)+1);
         i++;
         temp=t.substring(i,i+1);
        }
        return(t.charAt(i));

}
}


================================================================================================================================================

394. Decode String

public class Solution {
    public String decodeString(String s) {
        int i=0,k;
        char c;
        int rep=0;
        String strtotal="";
        String str="";
        String todecode="";
        boolean strb=false;
        while (i<s.length())
         {
          c=s.charAt(i);
          i++;
          if (c==']')
           {
            strb=false;
            for (k=0;k<rep;k++) strtotal=strtotal+str;
            rep=0;
            str="";
           }
          else
           if (c=='[')
            {
             strb=true; 
             str="";
            } 
           else
            {
             if ((c<'0') || (c>'9') && (strb))
              {
               str=str+c;   
              }
             if ((c>='0') && (c<='9') && (strb)) 
              {
               todecode=todecode+c;
               int j=1;  
               boolean firsttime=true;
               while (j>0)
                {
                 c=s.charAt(i);
                 i++;
                 if (c=='[')
                  {
                   if (firsttime)
                    firsttime=false;
                   else
                    j++;
                  }
                 if (c==']') j--;
                 todecode=todecode+c;
                }
               str=str+decodeString(todecode); 
               todecode="";
              }
             if ((c>='0') && (c<='9') && (!strb)) 
              {
               rep=rep*10+c-'0';   
              }
             if ((c<'0') || (c>'9') && (!strb))
              {
               strtotal=strtotal+c;   
              }
            }
         }
        return(strtotal); 
    }
}

================================================================================================================================================

400. Nth Digit 

public class Solution {
    public int findNthDigit(int n) {

    long i,pos;
    long dig;
    long ndigit=0;
    long pr_ndigit=0;
    long ldigits;
    
    long x=n;
    
    x++; /* Including zero */
    
    dig=0;
    ldigits=0;
    while (ndigit<x)    /* Calculating how many digits */
     {
      pr_ndigit=ndigit;      
      dig++;
      long tmp=(long)Math.pow(10,dig);
      ndigit=tmp*dig-ldigits;
      ldigits=ldigits+tmp;
     }
    ndigit=pr_ndigit;
    pos=ndigit-dig+1;
    
    if (pos<=0) pos=1;      /* Pointing to last number with 1 digit less */
    i=(long)Math.pow(10,dig-1)-1;

    i=i+(x-pos)/dig;             /* Find what nummer has the nth digit */
    pos=(x)-(x-pos)%dig; 
    pos=pos+dig-1;

    while (pos!=x)          /* Getting digit */
     {
      i=i/10;
      pos--;
     }
    i=i%10;
    
   return((int)i);
  }
}

================================================================================================================================================

404. Sum of Left Leaves 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        
        int sum=0;
        if (root!=null)
         {
          if (root.right!=null) sum=sum+sumOfLeftLeaves(root.right);
          if (root.left!=null) 
           { 
             if ((root.left.left==null) && (root.left.right==null)) 
              sum=sum+root.left.val; 
             else
              sum=sum+sumOfLeftLeaves(root.left);
           }
         }

        return(sum);
    }
}

================================================================================================================================================

412. Fizz Buzz 

public class Solution {
    public List<String> fizzBuzz(int n) {
        
        int i;
        
        List<String> a = new ArrayList<>();
        
        String r="";
        for (i=1;i<=n;i++)
        {   
         r="";
         if (((i%5)*(i%3))!=0) r=r+i;
          else
         { 
          if (i%3==0) r=r+"Fizz";
          if (i%5==0) r=r+"Buzz";
         }
         a.add(r);
        }
        return(a);
        
    }
}
================================================================================================================================================

415. Add Strings 


public class Solution {
    public String addStrings(String num1, String num2) {
        
        String r="";
        
        int i=0,x;
        boolean vaium=false;
        
        while  ((i<num1.length()) || (i<num2.length()))
         {
          x=0;
          if (i<num1.length()) x=x+(num1.charAt(num1.length()-1-i))-'0';    
          if (i<num2.length()) x=x+(num2.charAt(num2.length()-1-i))-'0';    
          x= vaium ? x+1 : x ;
          r=(char)(x%10+'0')+r;
          vaium=(x/10!=0);
          i++;
         }
        return (vaium ? '1'+r : r);
        
        
    }
}

================================================================================================================================================

419. Battleships in a Board 

public class Solution {
    public int countBattleships(char[][] board) {
        
    boolean track[]=new boolean [board[0].length];
    
    int i,j,cnt=0;
    
    for (i=0;i<track.length;i++) track[i]=false;
    
    for (i=0;i<board.length;i++)
     {
      for (j=0;j<board[i].length;j++)
       {
        if (board[i][j]=='X')
         {
          track[j]=true;
          if ((j>0) && (track[j-1])) track[j-1]=false; /* making long horizontal ships size 1 to not count more */
         }
        else
         {
          if (track[j])
           {
            track[j]=false;
            cnt++;
           }   
         }
       }
     }
    for (i=0;i<track.length;i++) if(track[i]) cnt++;
    return(cnt);
   }
}
 ================================================================================================================================================

437. Path Sum III 


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int pathSum(TreeNode root, int sum) {
         
        int r=0;
        if (root!=null)
         { 
          if (root.val==sum) r++;
          if (root.left!=null)  r=r+pathSum(root.left,sum)+startsum(root.left,sum-root.val);
          if (root.right!=null) r=r+pathSum(root.right,sum)+startsum(root.right,sum-root.val);
         }
        return (r);
    }
    
    public int startsum(TreeNode root, int sum)
    {
     int r=0;
     if (root.val==sum) r++;
     if (root.left!=null) r=r+startsum(root.left,sum-root.val);
     if (root.right!=null) r=r+startsum(root.right,sum-root.val);
     return(r);
    }
}

================================================================================================================================================

448. Find All Numbers Disappeared in an Array

public class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        
        int i,j,x;
        
        
        for (i=1;i<=nums.length;i++)
        {
         if (nums[i-1]!=i)
          {
           j=nums[i-1]; 
           while (nums[j-1]!=j)
            {
             x=nums[j-1];
             nums[j-1]=j;
             j=x;
            }
          }
        }
        
        List<Integer> r = new ArrayList<Integer>();
        
        for (i=1;i<=nums.length;i++)
        {
         if (nums[i-1]!=i)
          {
           r.add(i); 
          }
        }
        
        return(r);
    }
}

================================================================================================================================================

463. Island Perimeter

public class Solution {
    public int islandPerimeter(int[][] grid) {
        int i,j,p=0;
        
        for (i=0;i<grid.length;i++)
        {
            for (j=0;j<grid[i].length;j++)
            {
                if (grid[i][j]==1)
                {
                 if (i==0) 
                   p++;
                 else
                  if (grid[i-1][j]==0) p++;
                 if (j==0) 
                  p++;
                 else
                  if (grid[i][j-1]==0) p++;
                 if (i==grid.length-1) 
                   p++;
                 else
                  if (grid[i+1][j]==0) p++;
                 if (j==grid[i].length-1) 
                   p++;
                 else
                  if (grid[i][j+1]==0) p++;                 
                }
            }
        }
        return(p);
    }
    
}

================================================================================================================================================

530. Minimum Absolute Difference in BST 


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int getMinimumDifference(TreeNode root) {
     int r=-1,l=-1;        
     if (root!=null)
      {
       if (root.left!=null)
        {
         l=findMinDiff(root.left,root.val);
         int x=getMinimumDifference(root.left);
         if ((x>=0) && (x<l)) l=x;
        }
       if (root.right!=null)
        {
         r=findMinDiff(root.right,root.val);
         int x=getMinimumDifference(root.right);
         if ((x>=0) && (x<r)) r=x;
        }
      }
     if ((r>=0) && (l>=0)) return (r < l ? r : l);
     return ( r < 0 ? l : r);
    }

int findMinDiff(TreeNode root, int n)
 {
  int dif,l,r;
  if (root==null) return (-1);
  dif=Math.abs(root.val-n);
  if (root.left!=null) 
   {
    if (Math.abs(root.left.val-n)<dif) dif=Math.abs(root.left.val-n);
    int x=findMinDiff(root.left,n);
    if ((x>=0) && (x<dif)) dif=x;
   }
  if (root.right!=null)
   {
    if (Math.abs(root.right.val-n)<dif) dif=Math.abs(root.right.val-n);
    int x=findMinDiff(root.right,n);
    if ((x>=0) && (x<dif)) dif=x;
   }
  return(dif);
 }
}

================================================================================================================================================

535. Encode and Decode TinyURL 

public class Codec {

Map<String, String> urls = new HashMap<>();  
char max=126; 
char min=33;  


    // Encodes a URL to a shortened URL.
    public String encode(String longUrl) {
        
        if (urls.containsKey(longUrl))
         return(urls.get(longUrl));
        else
         {
          Random rand = new Random();    
          String str="xxx";
          while (str.equals("xxx"))
           {
            str="http://tinyurl.com/";
            for (int i=0;i<6;i++)
             {
              str=str+(char)(min+rand.nextInt(max-min+1));     
             }
            if (urls.containsValue(str)) str="xxx";
           }
          urls.put(longUrl,str);
          System.out.println(str);
          return(str);
         }
    }

    // Decodes a shortened URL to its original URL.
    public String decode(String shortUrl) {
        if (!urls.containsValue(shortUrl))
         return("");
        else
         {
          for(Map.Entry entry: urls.entrySet())
           {
            if(shortUrl.equals(entry.getValue()))
             {
              return(""+entry.getKey());

             }
           }
         }
         return("");
    }
        

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(url));


// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(url));


}

================================================================================================================================================

541. Reverse String II 


char* reverseStr(char* s, int k) {
 int i=0;
 bool invert=true;
 
 while (i+k<strlen(s))
  {
   if (invert)
    {
     revertK(s+i,k);
     invert=false;
    }
   else
    invert=true;
   i=i+k;
  }      
 if (invert) revertK(s+i,strlen(s)-i); 
 return(s);
}

void revertK (char* s, int k)
{
 int i=0;
 char c;
 
 while (i<k-i-1)
  {
   c=s[i];
   s[i]=s[k-i-1];
   s[k-i-1]=c;
   i++;
  }
}


================================================================================================================================================
