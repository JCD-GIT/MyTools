================================================================================================================================================

118. Pascal's Triangle 

public class Solution {
    public List<List<Integer>> generate(int numRows) {
        
        int i,j;
        
        List<List<Integer>> r = new ArrayList<>();
  
        int prev_line[] = new int[numRows];
        int line[] = new int [numRows];
        
        for (i=1;i<=numRows;i++)
        {
         List<Integer> l = new ArrayList<>();
         line[0]=1;
         for (j=1;j<i-1;j++)
          {
           line[j]=prev_line[j-1]+prev_line[j];   
          }
         line[i-1]=1;
         for (j=0;j<i;j++)
          {
           prev_line[j]=line[j];
           l.add(line[j]);
          }
          r.add(l);
          /* l.clear();  */
          l=null; /* To release the memory used for l */
        }
        return(r);
    }
}

================================================================================================================================================

122. Best Time to Buy and Sell Stock II 

public class Solution {
    public int maxProfit(int[] prices) {
        
        int i,dif=0,profit=0;
        
        int min=-1;
        
        for (i=0;i<prices.length;i++)
        {
         if (min<0) 
          min=prices[i];
         else
          { 
           if (prices[i]>min+dif) dif=prices[i]-min; 
           if ((prices[i]<prices[i-1]) && (dif!=0))
            {
              profit=profit+dif;
              dif=0;
              min=prices[i];
            }
           if (prices[i]<min) min=prices[i];
          }
 
        }
        profit=profit+dif;
        return(profit);
    }
}

================================================================================================================================================

143. Reorder List 

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void reorderList(ListNode head) {

        ListNode p,p1=head,p2=head;
        
        /*  Find Center */
        
        while (p2!=null)
         {
          p2=p2.next;
          if (p2!=null) 
           { 
               p2=p2.next;
               p1=p1.next;
           }
         }
        if (p1!=null)
         {
             p2=p1.next;
             p1.next=null;
             p1=p2;
         }

/* print_cadeia(head);
print_cadeia(p1);*/

        /* Invert (half) list */

        ListNode p_prev=null;
        while (p1!=null)
        {
         ListNode p_next=p1.next;
         p1.next=p_prev;
         p_prev=p1;
         p1=p_next;
        }
        p1=p_prev;
        
/* print_cadeia(head);
print_cadeia(p1);*/

        /* Merge */
        p2=head;
        while ((p1!=null) && (p2!=null))
        {
            ListNode p2_next=p2.next;
            p2.next=p1;
            ListNode p1_next=p1.next;
            p1.next=p2_next;
            p2=p2_next;
            p1=p1_next;
        }

/* print_cadeia(head); */

}
    
void print_cadeia(ListNode p)
{
while (p.next!=null)
{
    System.out.print(p.val+" ");
    p=p.next;
}
System.out.println(p.val);
}
    
    
}

================================================================================================================================================

150. Evaluate Reverse Polish Notation 

public class Solution {
    public int evalRPN(String[] tokens) {
        Deque <Integer> p = new LinkedList<>();
        
        int i,temp;
        
        boolean isNumber;
        
        for (i=0;i<tokens.length;i++)
        {
         isNumber=true;
         if  (tokens[i].equals("+"))
         {
          temp=p.removeFirst();
          temp=p.removeFirst()+temp;
          p.addFirst(temp);
          isNumber=false;
         }
         if  (tokens[i].equals("-"))
         {
          temp=p.removeFirst();
          temp=p.removeFirst()-temp;
          p.addFirst(temp);
          isNumber=false;
         }
         if  (tokens[i].equals("*"))
         {
          temp=p.removeFirst();
          temp=p.removeFirst()*temp;
          p.addFirst(temp);
          isNumber=false;
         }
         if  (tokens[i].equals("/"))
         {
          temp=p.removeFirst();
          temp=p.removeFirst()/temp;
          p.addFirst(temp);
          isNumber=false;
         }
         if (isNumber)
          {
           p.addFirst(Integer.parseInt(tokens[i]));  
          }
        }
        return (p.peekFirst());
    }
}

================================================================================================================================================

155. Min Stack  

/* public class MinStack {
    long min;
    Stack<Long> stack;

    public MinStack(){
        stack=new Stack<>();
    }
*/
public class MinStack {

    Deque <Integer> stack;
    Deque <Integer> minstack;
    
    /** initialize your data structure here. */
    public MinStack() {
        /* Create two stacks, 1 for min */ 
        stack = new LinkedList<>(); 
        minstack = new LinkedList<>(); 
        
    }
    
    public void push(int x) {
        /* If x < min push x to minstack, if not push min */
        
        int min=x;
        stack.addFirst(x);
        if (!minstack.isEmpty()) min = getMin();
        if (x < min)  min =x;
        minstack.addFirst(min);
        
    }
    
    public void pop() {
        /* Get and remove last value from stack and min stack */
        minstack.removeFirst();
        stack.removeFirst();
    }
    
    public int top() {
        /* Get last value from stack */
        return (stack.peekFirst());
    }
    
    public int getMin() {
        /* Get last value from min stack */
        
        return (minstack.peekFirst());
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */

================================================================================================================================================

217. Contains Duplicate  

public class Solution {
    public boolean containsDuplicate(int[] nums) {
        
       Map<Integer, Integer> ns = new HashMap<>();
       
       int i;
       
       for (i=0; i< nums.length; i++)
        {
         if (ns.containsKey(nums[i]))
          return (true);
         else
          ns.put(nums[i],i);
        }
        return(false);
    }
}


================================================================================================================================================

231. Power of Two 

public class Solution {
    public boolean isPowerOfTwo(int n) {
        int x,c=0;
        
        for (x=1;(x>0)&&(n>0);x=x<<1)
        {
         if ((n&x)!=0) c++;
         if (c==2) return (false);
        }
        return (c==1) ? true : false;  
        
/* Solution using hashmap */        
        
/* Map<Integer,Integer> power2 = new HashMap<>();  
int x=1;
while ( (x>0) && (!power2.containsKey(n)) )
 {
  power2.put(x,x);
  x=x<<1;
 }
return(power2.containsKey(n)); */
        
    }
}

================================================================================================================================================

283. Move Zeroes 

void moveZeroes(int* nums, int numsSize) {
    
    int i,j;
    
    i=0;
    j=0;
    
    while (j<numsSize)
    {
        if (nums[j]==0)
         {
          j++;
         }
        else
         {
          if (i!=j) nums[i]=nums[j];        
          i++;
          j++;
         }
    }
    for (;i<numsSize;i++) nums[i]=0;
    return;
}


================================================================================================================================================

292. Nim Game

public class Solution {
    public boolean canWinNim(int n) {
        if (n>0)
         {
          if (n%4!=0) return (true);
         }
        return (false);
    }
}

================================================================================================================================================

336. Palindrome Pairs

public class Solution {


    public List<List<Integer>> palindromePairs(String[] words) {
        Map<String, List<Integer>> complements = new HashMap<>();
        
        int i,j,k;
        int dif_start;
        
        List<List<Integer>> r = new ArrayList<List<Integer>>();
        
        for (i=0; i<words.length;i++)            /* Add all words to a hash table */
        {
            if (!complements.containsKey(words[i])) /* If word is not repeated it's added as a new entry */
             {
              List<Integer> temp = new ArrayList<Integer>();
              temp.add(i);
              complements.put(words[i],temp);
             }
            else                                 /* If word is repeated it's added as a same entry adding sequence number to list */     
             {
              List<Integer> temp = new ArrayList<Integer>();
              temp = complements.get(words[i]); 
              temp.add(i);
              complements.put(words[i],temp);
             }
        }
        
        for (i=0; i<words.length;i++)
        {
         if ((isPalindrome(words[i])) && complements.containsKey(""))  
          {
            List<Integer> temp = new ArrayList<Integer>();
            temp = complements.get("");
            for (k=0; k<temp.size(); k++)
             {
                 if (i!=temp.get(k))
                  {
                   List<Integer> rtemp = new ArrayList<Integer>();
                   rtemp.add(i);
                   rtemp.add(temp.get(k));
                   r.add(rtemp);
                   List<Integer> rtemp2 = new ArrayList<Integer>();
                   rtemp2.add(temp.get(k));
                   rtemp2.add(i);
                   r.add(rtemp2);
                  }
             }
          }


         if (complements.containsKey(reverse(words[i]))) /* add i with found key to answer if not i */ 
          {
            List<Integer> temp = new ArrayList<Integer>();
            temp = complements.get(reverse(words[i]));
            for (k=0; k<temp.size(); k++)
             {
                 if (i!=temp.get(k))
                  {
                   List<Integer> rtemp = new ArrayList<Integer>();
                   rtemp.add(i);
                   rtemp.add(temp.get(k));
                   r.add(rtemp);
                  }
             }
          }
         
         for (j=1;j<words[i].length();j=j+1)    
          {
           if(isPalindrome(words[i].substring(0,words[i].length()-j)))  /* Trying to find palindromes to last letters */
            {
             if (complements.containsKey(reverse(words[i].substring(words[i].length()-j)))) /* add i with found key to answer if not i */
             {
              List<Integer> temp = new ArrayList<Integer>();
              temp = complements.get(reverse(words[i].substring(words[i].length()-j)));
              for (k=0; k<temp.size(); k++)
               {
                if (i!=temp.get(k))
                 {
                  List<Integer> rtemp = new ArrayList<Integer>();
                  rtemp.add(temp.get(k));
                  rtemp.add(i);
                  r.add(rtemp);
                 }
               }
             }
           }           
          if(isPalindrome(words[i].substring(j)))    /* Trying to find palindromes to first letters */
            {
             if (complements.containsKey(reverse(words[i].substring(0,j)))) /* add i with found key to answer if not i */ 
              {
               List<Integer> temp = new ArrayList<Integer>();
               temp = complements.get(reverse(words[i].substring(0,j)));
               for (k=0; k<temp.size(); k++)
                {
                 if (i!=temp.get(k))
                  {
                   List<Integer> rtemp = new ArrayList<Integer>();
                   rtemp.add(i);
                   rtemp.add(temp.get(k));
                   r.add(rtemp);
                  }
                }
              }
            }

         }
         
    }
    return(r);
}
    
 String reverse (String s)
  {
   int i;
   String r="";
   for (i=0;i<s.length();i++)
    {
     r=s.charAt(i)+r;         
    }
   return(r); 
  }
    
boolean isPalindrome (String s)
  {
   int i;
   
   for (i=0;i<s.length()-i;i++)
    {
     if(s.charAt(i)!=s.charAt(s.length()-i-1)) return(false);         
    }
   return(true); 
  }
    
}

================================================================================================================================================

374. Guess Number Higher or Lower   

/* The guess API is defined in the parent class GuessGame.
   @param num, your guess
   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
      int guess(int num); */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        
        int min=1, max=n, x=0, status=2;
        
        while (status!=0)
         {
          x=(max-min)/2+min;
          status=guess(x);
          if (status==1) 
            min=x+1;
           else
            max=x-1;
          } 
        return(x);
    }
}

================================================================================================================================================

389. Find the Difference  


public class Solution {
    public char findTheDifference(String s, String t) {
        
        int i;
        String temp;
        
        i=0;
        temp=t.substring(i,i+1);
        
        while (s.contains(temp))
        {
         s=s.substring(0,s.indexOf(temp))+s.substring(s.indexOf(temp)+1);
         i++;
         temp=t.substring(i,i+1);
        }
        return(t.charAt(i));

}
}


================================================================================================================================================

404. Sum of Left Leaves 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        
        int sum=0;
        if (root!=null)
         {
          if (root.right!=null) sum=sum+sumOfLeftLeaves(root.right);
          if (root.left!=null) 
           { 
             if ((root.left.left==null) && (root.left.right==null)) 
              sum=sum+root.left.val; 
             else
              sum=sum+sumOfLeftLeaves(root.left);
           }
         }

        return(sum);
    }
}

================================================================================================================================================

412. Fizz Buzz 

public class Solution {
    public List<String> fizzBuzz(int n) {
        
        int i;
        
        List<String> a = new ArrayList<>();
        
        String r="";
        for (i=1;i<=n;i++)
        {   
         r="";
         if (((i%5)*(i%3))!=0) r=r+i;
          else
         { 
          if (i%3==0) r=r+"Fizz";
          if (i%5==0) r=r+"Buzz";
         }
         a.add(r);
        }
        return(a);
        
    }
}
================================================================================================================================================

415. Add Strings 


public class Solution {
    public String addStrings(String num1, String num2) {
        
        String r="";
        
        int i=0,x;
        boolean vaium=false;
        
        while  ((i<num1.length()) || (i<num2.length()))
         {
          x=0;
          if (i<num1.length()) x=x+(num1.charAt(num1.length()-1-i))-'0';    
          if (i<num2.length()) x=x+(num2.charAt(num2.length()-1-i))-'0';    
          x= vaium ? x+1 : x ;
          r=(char)(x%10+'0')+r;
          vaium=(x/10!=0);
          i++;
         }
        return (vaium ? '1'+r : r);
        
        
    }
}

================================================================================================================================================

437. Path Sum III 


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int pathSum(TreeNode root, int sum) {
         
        int r=0;
        if (root!=null)
         { 
          if (root.val==sum) r++;
          if (root.left!=null)  r=r+pathSum(root.left,sum)+startsum(root.left,sum-root.val);
          if (root.right!=null) r=r+pathSum(root.right,sum)+startsum(root.right,sum-root.val);
         }
        return (r);
    }
    
    public int startsum(TreeNode root, int sum)
    {
     int r=0;
     if (root.val==sum) r++;
     if (root.left!=null) r=r+startsum(root.left,sum-root.val);
     if (root.right!=null) r=r+startsum(root.right,sum-root.val);
     return(r);
    }
}

================================================================================================================================================

448. Find All Numbers Disappeared in an Array

public class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        
        int i,j,x;
        
        
        for (i=1;i<=nums.length;i++)
        {
         if (nums[i-1]!=i)
          {
           j=nums[i-1]; 
           while (nums[j-1]!=j)
            {
             x=nums[j-1];
             nums[j-1]=j;
             j=x;
            }
          }
        }
        
        List<Integer> r = new ArrayList<Integer>();
        
        for (i=1;i<=nums.length;i++)
        {
         if (nums[i-1]!=i)
          {
           r.add(i); 
          }
        }
        
        return(r);
    }
}

================================================================================================================================================

463. Island Perimeter

public class Solution {
    public int islandPerimeter(int[][] grid) {
        int i,j,p=0;
        
        for (i=0;i<grid.length;i++)
        {
            for (j=0;j<grid[i].length;j++)
            {
                if (grid[i][j]==1)
                {
                 if (i==0) 
                   p++;
                 else
                  if (grid[i-1][j]==0) p++;
                 if (j==0) 
                  p++;
                 else
                  if (grid[i][j-1]==0) p++;
                 if (i==grid.length-1) 
                   p++;
                 else
                  if (grid[i+1][j]==0) p++;
                 if (j==grid[i].length-1) 
                   p++;
                 else
                  if (grid[i][j+1]==0) p++;                 
                }
            }
        }
        return(p);
    }
    
}

================================================================================================================================================

530. Minimum Absolute Difference in BST 


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int getMinimumDifference(TreeNode root) {
     int r=-1,l=-1;        
     if (root!=null)
      {
       if (root.left!=null)
        {
         l=findMinDiff(root.left,root.val);
         int x=getMinimumDifference(root.left);
         if ((x>=0) && (x<l)) l=x;
        }
       if (root.right!=null)
        {
         r=findMinDiff(root.right,root.val);
         int x=getMinimumDifference(root.right);
         if ((x>=0) && (x<r)) r=x;
        }
      }
     if ((r>=0) && (l>=0)) return (r < l ? r : l);
     return ( r < 0 ? l : r);
    }

int findMinDiff(TreeNode root, int n)
 {
  int dif,l,r;
  if (root==null) return (-1);
  dif=Math.abs(root.val-n);
  if (root.left!=null) 
   {
    if (Math.abs(root.left.val-n)<dif) dif=Math.abs(root.left.val-n);
    int x=findMinDiff(root.left,n);
    if ((x>=0) && (x<dif)) dif=x;
   }
  if (root.right!=null)
   {
    if (Math.abs(root.right.val-n)<dif) dif=Math.abs(root.right.val-n);
    int x=findMinDiff(root.right,n);
    if ((x>=0) && (x<dif)) dif=x;
   }
  return(dif);
 }
}


================================================================================================================================================
